
module CreusotContracts_Invariant_Inv_Stub
  type t
  predicate inv (_x : t)
end
module CreusotContracts_Invariant_Inv_Interface
  type t
  predicate inv (_x : t)
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module CreusotContracts_Invariant_Inv
  type t
  predicate inv (_x : t) =
    [#"../../../../creusot/creusot-contracts/src/invariant.rs" 16 4 16 8] true
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module TyInv_Trivial
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  axiom inv_trivial : forall self : t . Inv0.inv self = true
end
module CargoDir_Lemmas_MapSetCommute_Stub
  type k
  type v
  use map.Map
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Map.map k v
  function map_set_commute [#"../src/lib.rs" 15 4 15 78] (x : Map.map k v) (k1 : k) (k2 : k) (v1 : v) (v2 : v) : ()
end
module CargoDir_Lemmas_MapSetCommute_Interface
  type k
  type v
  use map.Map
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Map.map k v
  function map_set_commute [#"../src/lib.rs" 15 4 15 78] (x : Map.map k v) (k1 : k) (k2 : k) (v1 : v) (v2 : v) : ()
  val map_set_commute [#"../src/lib.rs" 15 4 15 78] (x : Map.map k v) (k1 : k) (k2 : k) (v1 : v) (v2 : v) : ()
    requires {[#"../src/lib.rs" 13 15 13 23] k1 <> k2}
    requires {[#"../src/lib.rs" 15 33 15 34] Inv0.inv x}
    requires {[#"../src/lib.rs" 15 51 15 53] Inv1.inv k1}
    requires {[#"../src/lib.rs" 15 58 15 60] Inv1.inv k2}
    requires {[#"../src/lib.rs" 15 65 15 67] Inv2.inv v1}
    requires {[#"../src/lib.rs" 15 72 15 74] Inv2.inv v2}
    ensures { [#"../src/lib.rs" 14 14 14 68] Map.set (Map.set x k1 v1) k2 v2 = Map.set (Map.set x k2 v2) k1 v1 }
    ensures { result = map_set_commute x k1 k2 v1 v2 }
    
  axiom map_set_commute_spec : forall x : Map.map k v, k1 : k, k2 : k, v1 : v, v2 : v . ([#"../src/lib.rs" 13 15 13 23] k1 <> k2) -> ([#"../src/lib.rs" 15 33 15 34] Inv0.inv x) -> ([#"../src/lib.rs" 15 51 15 53] Inv1.inv k1) -> ([#"../src/lib.rs" 15 58 15 60] Inv1.inv k2) -> ([#"../src/lib.rs" 15 65 15 67] Inv2.inv v1) -> ([#"../src/lib.rs" 15 72 15 74] Inv2.inv v2) -> ([#"../src/lib.rs" 14 14 14 68] Map.set (Map.set x k1 v1) k2 v2 = Map.set (Map.set x k2 v2) k1 v1)
end
module CargoDir_Lemmas_MapSetCommute
  type k
  type v
  use map.Map
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Map.map k v
  function map_set_commute [#"../src/lib.rs" 15 4 15 78] (x : Map.map k v) (k1 : k) (k2 : k) (v1 : v) (v2 : v) : () =
    [#"../src/lib.rs" 11 4 11 10] ()
  val map_set_commute [#"../src/lib.rs" 15 4 15 78] (x : Map.map k v) (k1 : k) (k2 : k) (v1 : v) (v2 : v) : ()
    requires {[#"../src/lib.rs" 13 15 13 23] k1 <> k2}
    requires {[#"../src/lib.rs" 15 33 15 34] Inv0.inv x}
    requires {[#"../src/lib.rs" 15 51 15 53] Inv1.inv k1}
    requires {[#"../src/lib.rs" 15 58 15 60] Inv1.inv k2}
    requires {[#"../src/lib.rs" 15 65 15 67] Inv2.inv v1}
    requires {[#"../src/lib.rs" 15 72 15 74] Inv2.inv v2}
    ensures { [#"../src/lib.rs" 14 14 14 68] Map.set (Map.set x k1 v1) k2 v2 = Map.set (Map.set x k2 v2) k1 v1 }
    ensures { result = map_set_commute x k1 k2 v1 v2 }
    
  axiom map_set_commute_spec : forall x : Map.map k v, k1 : k, k2 : k, v1 : v, v2 : v . ([#"../src/lib.rs" 13 15 13 23] k1 <> k2) -> ([#"../src/lib.rs" 15 33 15 34] Inv0.inv x) -> ([#"../src/lib.rs" 15 51 15 53] Inv1.inv k1) -> ([#"../src/lib.rs" 15 58 15 60] Inv1.inv k2) -> ([#"../src/lib.rs" 15 65 15 67] Inv2.inv v1) -> ([#"../src/lib.rs" 15 72 15 74] Inv2.inv v2) -> ([#"../src/lib.rs" 14 14 14 68] Map.set (Map.set x k1 v1) k2 v2 = Map.set (Map.set x k2 v2) k1 v1)
end
module CargoDir_Lemmas_MapSetCommute_Impl
  type k
  type v
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = v,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = k,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Map.map k v
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Map.map k v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  let rec ghost function map_set_commute [#"../src/lib.rs" 15 4 15 78] (x : Map.map k v) (k1 : k) (k2 : k) (v1 : v) (v2 : v) : ()
    requires {[#"../src/lib.rs" 13 15 13 23] k1 <> k2}
    requires {[#"../src/lib.rs" 15 33 15 34] Inv0.inv x}
    requires {[#"../src/lib.rs" 15 51 15 53] Inv1.inv k1}
    requires {[#"../src/lib.rs" 15 58 15 60] Inv1.inv k2}
    requires {[#"../src/lib.rs" 15 65 15 67] Inv2.inv v1}
    requires {[#"../src/lib.rs" 15 72 15 74] Inv2.inv v2}
    ensures { [#"../src/lib.rs" 14 14 14 68] Map.set (Map.set x k1 v1) k2 v2 = Map.set (Map.set x k2 v2) k1 v1 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../src/lib.rs" 11 4 11 10] ()
end
module CreusotContracts_GhostPtr_GhostPtrToken_Type
  type t_ghostptrtoken 't
end
module CargoDir_LinkedList_Node_Type
  use prelude.Opaque
  type t_node 't =
    | C_Node 't opaque_ptr opaque_ptr
    
  let function node_prev (self : t_node 't) : opaque_ptr = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Node _ _ a -> a
      end
  let function node_next (self : t_node 't) : opaque_ptr = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Node _ a _ -> a
      end
  let function node_data (self : t_node 't) : 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Node a _ _ -> a
      end
end
module CargoDir_LinkedList_LinkedList_Type
  use prelude.Opaque
  use prelude.Ghost
  use seq.Seq
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  type t_linkedlist 't =
    | C_LinkedList opaque_ptr opaque_ptr (Ghost.ghost_ty (Seq.seq opaque_ptr)) (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node 't))
    
  let function linkedlist_ptrs (self : t_linkedlist 't) : Ghost.ghost_ty (Seq.seq opaque_ptr)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_LinkedList _ _ a _ -> a
      end
  let function linkedlist_token (self : t_linkedlist 't) : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node 't)
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_LinkedList _ _ _ a -> a
      end
  let function linkedlist_head (self : t_linkedlist 't) : opaque_ptr = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_LinkedList a _ _ _ -> a
      end
  let function linkedlist_tail (self : t_linkedlist 't) : opaque_ptr = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_LinkedList _ a _ _ -> a
      end
end
module CreusotContracts_Logic_Fmap_FMap_Type
  type t_fmap 'k 'v
end
module CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub
  type t
  use prelude.Opaque
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  function shallow_model (self : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
    
end
module CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface
  type t
  use prelude.Opaque
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  function shallow_model (self : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
    
  val shallow_model (self : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
    ensures { result = shallow_model self }
    
end
module CreusotContracts_GhostPtr_Impl0_ShallowModel
  type t
  use prelude.Opaque
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  function shallow_model (self : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
    
  val shallow_model (self : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
    ensures { result = shallow_model self }
    
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
end
module CreusotContracts_Logic_Fmap_Impl0_Mk_Stub
  type k
  type v
  use map.Map
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  function mk (_m : Map.map k (Core_Option_Option_Type.t_option v)) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
end
module CreusotContracts_Logic_Fmap_Impl0_Mk_Interface
  type k
  type v
  use map.Map
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  function mk (_m : Map.map k (Core_Option_Option_Type.t_option v)) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  val mk (_m : Map.map k (Core_Option_Option_Type.t_option v)) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    ensures { result = mk _m }
    
end
module CreusotContracts_Logic_Fmap_Impl0_Mk
  type k
  type v
  use map.Map
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  function mk (_m : Map.map k (Core_Option_Option_Type.t_option v)) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  val mk (_m : Map.map k (Core_Option_Option_Type.t_option v)) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    ensures { result = mk _m }
    
end
module CreusotContracts_Logic_Fmap_Impl0_View_Stub
  type k
  type v
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  function view (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : Map.map k (Core_Option_Option_Type.t_option v)
    
end
module CreusotContracts_Logic_Fmap_Impl0_View_Interface
  type k
  type v
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  function view (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : Map.map k (Core_Option_Option_Type.t_option v)
    
  val view (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : Map.map k (Core_Option_Option_Type.t_option v)
    requires {[#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 28 16 28 20] Inv0.inv self}
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 27 14 27 38] Mk0.mk result = self }
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 28 4 28 35] Inv1.inv result }
    ensures { result = view self }
    
  axiom view_spec : forall self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v . ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 28 16 28 20] Inv0.inv self) -> ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 28 4 28 35] Inv1.inv (view self)) && ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 27 14 27 38] Mk0.mk (view self) = self)
end
module CreusotContracts_Logic_Fmap_Impl0_View
  type k
  type v
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  function view (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : Map.map k (Core_Option_Option_Type.t_option v)
    
  val view (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : Map.map k (Core_Option_Option_Type.t_option v)
    requires {[#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 28 16 28 20] Inv0.inv self}
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 27 14 27 38] Mk0.mk result = self }
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 28 4 28 35] Inv1.inv result }
    ensures { result = view self }
    
  axiom view_spec : forall self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v . ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 28 16 28 20] Inv0.inv self) -> ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 28 4 28 35] Inv1.inv (view self)) && ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 27 14 27 38] Mk0.mk (view self) = self)
end
module CreusotContracts_Logic_Fmap_Impl0_Get_Stub
  type k
  type v
  use Core_Option_Option_Type as Core_Option_Option_Type
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function get [@inline:trivial] (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : Core_Option_Option_Type.t_option v
    
end
module CreusotContracts_Logic_Fmap_Impl0_Get_Interface
  type k
  type v
  use Core_Option_Option_Type as Core_Option_Option_Type
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function get [@inline:trivial] (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : Core_Option_Option_Type.t_option v
    
  val get [@inline:trivial] (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : Core_Option_Option_Type.t_option v
    ensures { result = get self k }
    
end
module CreusotContracts_Logic_Fmap_Impl0_Get
  type k
  type v
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  function get [@inline:trivial] (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : Core_Option_Option_Type.t_option v
    
   =
    [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 55 8 55 26] Map.get (View0.view self) k
  val get [@inline:trivial] (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : Core_Option_Option_Type.t_option v
    ensures { result = get self k }
    
end
module CreusotContracts_Logic_Fmap_Impl0_Contains_Stub
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function contains (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : bool
end
module CreusotContracts_Logic_Fmap_Impl0_Contains_Interface
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function contains (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : bool
  val contains (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : bool
    ensures { result = contains self k }
    
end
module CreusotContracts_Logic_Fmap_Impl0_Contains
  type k
  type v
  use Core_Option_Option_Type as Core_Option_Option_Type
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Get_Stub as Get0 with
    type k = k,
    type v = v
  function contains (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : bool =
    [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 77 8 77 27] Get0.get self k <> Core_Option_Option_Type.C_None
  val contains (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : bool
    ensures { result = contains self k }
    
end
module CreusotContracts_GhostPtr_Impl2_AddrLogic_Stub
  type t
  use prelude.Opaque
  use prelude.Int
  function addr_logic (self : opaque_ptr) : int
end
module CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface
  type t
  use prelude.Opaque
  use prelude.Int
  function addr_logic (self : opaque_ptr) : int
  val addr_logic (self : opaque_ptr) : int
    ensures { result = addr_logic self }
    
end
module CreusotContracts_GhostPtr_Impl2_AddrLogic
  type t
  use prelude.Opaque
  use prelude.Int
  function addr_logic (self : opaque_ptr) : int
  val addr_logic (self : opaque_ptr) : int
    ensures { result = addr_logic self }
    
end
module CreusotContracts_GhostPtr_Impl2_NullLogic_Stub
  type t
  use prelude.Opaque
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Stub as AddrLogic0 with
    type t = t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = t
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t
  function null_logic (_1 : ()) : opaque_ptr
end
module CreusotContracts_GhostPtr_Impl2_NullLogic_Interface
  type t
  use prelude.Opaque
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Stub as AddrLogic0 with
    type t = t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = t
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t
  function null_logic (_1 : ()) : opaque_ptr
  val null_logic (_1 : ()) : opaque_ptr
    ensures { [#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 128 4 128 64] forall t : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t . Inv0.inv t -> not Contains0.contains (ShallowModel0.shallow_model t) result }
    ensures { [#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 130 4 130 98] forall ptr : opaque_ptr . AddrLogic0.addr_logic ptr = AddrLogic0.addr_logic result -> ptr = result }
    ensures { result = null_logic _1 }
    
  axiom null_logic_spec : forall _1 : () . ([#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 130 4 130 98] forall ptr : opaque_ptr . AddrLogic0.addr_logic ptr = AddrLogic0.addr_logic (null_logic _1) -> ptr = null_logic _1) && ([#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 128 4 128 64] forall t : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t . Inv0.inv t -> not Contains0.contains (ShallowModel0.shallow_model t) (null_logic _1))
end
module CreusotContracts_GhostPtr_Impl2_NullLogic
  type t
  use prelude.Opaque
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Stub as AddrLogic0 with
    type t = t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = t
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t
  function null_logic (_1 : ()) : opaque_ptr
  val null_logic (_1 : ()) : opaque_ptr
    ensures { [#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 128 4 128 64] forall t : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t . Inv0.inv t -> not Contains0.contains (ShallowModel0.shallow_model t) result }
    ensures { [#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 130 4 130 98] forall ptr : opaque_ptr . AddrLogic0.addr_logic ptr = AddrLogic0.addr_logic result -> ptr = result }
    ensures { result = null_logic _1 }
    
  axiom null_logic_spec : forall _1 : () . ([#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 130 4 130 98] forall ptr : opaque_ptr . AddrLogic0.addr_logic ptr = AddrLogic0.addr_logic (null_logic _1) -> ptr = null_logic _1) && ([#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 128 4 128 64] forall t : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t . Inv0.inv t -> not Contains0.contains (ShallowModel0.shallow_model t) (null_logic _1))
end
module CreusotContracts_Logic_Ops_Impl6_IndexLogic_Stub
  type t
  use prelude.Ghost
  use seq.Seq
  use prelude.Int
  function index_logic [@inline:trivial] (self : Ghost.ghost_ty (Seq.seq t)) (ix : int) : t
end
module CreusotContracts_Logic_Ops_Impl6_IndexLogic_Interface
  type t
  use prelude.Ghost
  use seq.Seq
  use prelude.Int
  function index_logic [@inline:trivial] (self : Ghost.ghost_ty (Seq.seq t)) (ix : int) : t
  val index_logic [@inline:trivial] (self : Ghost.ghost_ty (Seq.seq t)) (ix : int) : t
    ensures { result = index_logic self ix }
    
end
module CreusotContracts_Logic_Ops_Impl6_IndexLogic
  type t
  use prelude.Ghost
  use seq.Seq
  use prelude.Int
  function index_logic [@inline:trivial] (self : Ghost.ghost_ty (Seq.seq t)) (ix : int) : t =
    [#"../../../../creusot/creusot-contracts/src/logic/ops.rs" 85 8 85 33] Seq.get (Ghost.inner self) ix
  val index_logic [@inline:trivial] (self : Ghost.ghost_ty (Seq.seq t)) (ix : int) : t
    ensures { result = index_logic self ix }
    
end
module CargoDir_LinkedList_Impl0_PrevOf_Stub
  type t
  use prelude.Int
  use prelude.Opaque
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  function prev_of [#"../src/lib.rs" 226 8 226 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    
end
module CargoDir_LinkedList_Impl0_PrevOf_Interface
  type t
  use prelude.Int
  use prelude.Opaque
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  function prev_of [#"../src/lib.rs" 226 8 226 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    
  val prev_of [#"../src/lib.rs" 226 8 226 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    requires {[#"../src/lib.rs" 225 19 225 25] i >= 0}
    ensures { result = prev_of self i }
    
end
module CargoDir_LinkedList_Impl0_PrevOf
  type t
  use prelude.Int
  use prelude.Opaque
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Stub as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic_Stub as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Stub as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  function prev_of [#"../src/lib.rs" 226 8 226 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    
   =
    [#"../src/lib.rs" 223 8 223 16] if i = 0 then
      NullLogic0.null_logic ()
    else
      IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) (i - 1)
    
  val prev_of [#"../src/lib.rs" 226 8 226 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    requires {[#"../src/lib.rs" 225 19 225 25] i >= 0}
    ensures { result = prev_of self i }
    
end
module CargoDir_LinkedList_Impl0_PrevOf_Impl
  type t
  use prelude.Int
  use prelude.Opaque
  use map.Map
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv1.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv1.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv2.inv
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  let rec ghost function prev_of [#"../src/lib.rs" 226 8 226 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    requires {[#"../src/lib.rs" 225 19 225 25] i >= 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../src/lib.rs" 223 8 223 16] if pure {i = 0} then
      NullLogic0.null_logic ()
    else
      IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) (i - 1)
    
end
module CargoDir_LinkedList_Impl0_NextOf_Stub
  type t
  use prelude.Int
  use prelude.Opaque
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  function next_of [#"../src/lib.rs" 237 8 237 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    
end
module CargoDir_LinkedList_Impl0_NextOf_Interface
  type t
  use prelude.Int
  use prelude.Opaque
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  function next_of [#"../src/lib.rs" 237 8 237 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    
  val next_of [#"../src/lib.rs" 237 8 237 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    requires {[#"../src/lib.rs" 236 19 236 25] i >= 0}
    ensures { result = next_of self i }
    
end
module CargoDir_LinkedList_Impl0_NextOf
  type t
  use prelude.Int
  use prelude.Opaque
  use prelude.Ghost
  use seq.Seq
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Stub as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic_Stub as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Stub as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  function next_of [#"../src/lib.rs" 237 8 237 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    
   =
    [#"../src/lib.rs" 234 8 234 16] if i + 1 = Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self)) then
      NullLogic0.null_logic ()
    else
      IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) (i + 1)
    
  val next_of [#"../src/lib.rs" 237 8 237 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    requires {[#"../src/lib.rs" 236 19 236 25] i >= 0}
    ensures { result = next_of self i }
    
end
module CargoDir_LinkedList_Impl0_NextOf_Impl
  type t
  use prelude.Int
  use prelude.Opaque
  use prelude.Ghost
  use seq.Seq
  use map.Map
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv1.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv1.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv2.inv
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  let rec ghost function next_of [#"../src/lib.rs" 237 8 237 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    requires {[#"../src/lib.rs" 236 19 236 25] i >= 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../src/lib.rs" 234 8 234 16] if pure {i + 1 = Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self))} then
      NullLogic0.null_logic ()
    else
      IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) (i + 1)
    
end
module CreusotContracts_Util_Unreachable_Stub
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  function unreachable (_1 : ()) : t
end
module CreusotContracts_Util_Unreachable_Interface
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  function unreachable (_1 : ()) : t
  val unreachable (_1 : ()) : t
    requires {[#"../../../../creusot/creusot-contracts/src/util.rs" 24 11 24 16] false}
    ensures { [#"../../../../creusot/creusot-contracts/src/util.rs" 25 10 25 15] false }
    ensures { [#"../../../../creusot/creusot-contracts/src/util.rs" 27 0 27 28] Inv0.inv result }
    ensures { result = unreachable _1 }
    
  axiom unreachable_spec : forall _1 : () . ([#"../../../../creusot/creusot-contracts/src/util.rs" 24 11 24 16] false) -> ([#"../../../../creusot/creusot-contracts/src/util.rs" 27 0 27 28] Inv0.inv (unreachable _1)) && ([#"../../../../creusot/creusot-contracts/src/util.rs" 25 10 25 15] false)
end
module CreusotContracts_Util_Unreachable
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  function unreachable (_1 : ()) : t
  val unreachable (_1 : ()) : t
    requires {[#"../../../../creusot/creusot-contracts/src/util.rs" 24 11 24 16] false}
    ensures { [#"../../../../creusot/creusot-contracts/src/util.rs" 25 10 25 15] false }
    ensures { [#"../../../../creusot/creusot-contracts/src/util.rs" 27 0 27 28] Inv0.inv result }
    ensures { result = unreachable _1 }
    
  axiom def : forall _1 : () . unreachable _1 = ([#"../../../../creusot/creusot-contracts/src/util.rs" 28 4 28 17] unreachable ())
  axiom unreachable_spec : forall _1 : () . ([#"../../../../creusot/creusot-contracts/src/util.rs" 24 11 24 16] false) -> ([#"../../../../creusot/creusot-contracts/src/util.rs" 27 0 27 28] Inv0.inv (unreachable _1)) && ([#"../../../../creusot/creusot-contracts/src/util.rs" 25 10 25 15] false)
end
module CreusotContracts_Util_Unwrap_Stub
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Option_Option_Type.t_option t
  function unwrap (op : Core_Option_Option_Type.t_option t) : t
end
module CreusotContracts_Util_Unwrap_Interface
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Option_Option_Type.t_option t
  function unwrap (op : Core_Option_Option_Type.t_option t) : t
  val unwrap (op : Core_Option_Option_Type.t_option t) : t
    requires {[#"../../../../creusot/creusot-contracts/src/util.rs" 33 11 33 21] op <> Core_Option_Option_Type.C_None}
    requires {[#"../../../../creusot/creusot-contracts/src/util.rs" 35 17 35 19] Inv0.inv op}
    ensures { [#"../../../../creusot/creusot-contracts/src/util.rs" 34 10 34 28] Core_Option_Option_Type.C_Some result = op }
    ensures { [#"../../../../creusot/creusot-contracts/src/util.rs" 35 0 35 36] Inv1.inv result }
    ensures { result = unwrap op }
    
  axiom unwrap_spec : forall op : Core_Option_Option_Type.t_option t . ([#"../../../../creusot/creusot-contracts/src/util.rs" 33 11 33 21] op <> Core_Option_Option_Type.C_None) -> ([#"../../../../creusot/creusot-contracts/src/util.rs" 35 17 35 19] Inv0.inv op) -> ([#"../../../../creusot/creusot-contracts/src/util.rs" 35 0 35 36] Inv1.inv (unwrap op)) && ([#"../../../../creusot/creusot-contracts/src/util.rs" 34 10 34 28] Core_Option_Option_Type.C_Some (unwrap op) = op)
end
module CreusotContracts_Util_Unwrap
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Util_Unreachable_Stub as Unreachable0 with
    type t = t,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Option_Option_Type.t_option t
  function unwrap (op : Core_Option_Option_Type.t_option t) : t =
    [#"../../../../creusot/creusot-contracts/src/util.rs" 36 4 39 5] match (op) with
      | Core_Option_Option_Type.C_Some t -> t
      | Core_Option_Option_Type.C_None -> Unreachable0.unreachable ()
      end
  val unwrap (op : Core_Option_Option_Type.t_option t) : t
    requires {[#"../../../../creusot/creusot-contracts/src/util.rs" 33 11 33 21] op <> Core_Option_Option_Type.C_None}
    requires {[#"../../../../creusot/creusot-contracts/src/util.rs" 35 17 35 19] Inv0.inv op}
    ensures { [#"../../../../creusot/creusot-contracts/src/util.rs" 34 10 34 28] Core_Option_Option_Type.C_Some result = op }
    ensures { [#"../../../../creusot/creusot-contracts/src/util.rs" 35 0 35 36] Inv1.inv result }
    ensures { result = unwrap op }
    
  axiom unwrap_spec : forall op : Core_Option_Option_Type.t_option t . ([#"../../../../creusot/creusot-contracts/src/util.rs" 33 11 33 21] op <> Core_Option_Option_Type.C_None) -> ([#"../../../../creusot/creusot-contracts/src/util.rs" 35 17 35 19] Inv0.inv op) -> ([#"../../../../creusot/creusot-contracts/src/util.rs" 35 0 35 36] Inv1.inv (unwrap op)) && ([#"../../../../creusot/creusot-contracts/src/util.rs" 34 10 34 28] Core_Option_Option_Type.C_Some (unwrap op) = op)
end
module CreusotContracts_Logic_Fmap_Impl0_LookupUnsized_Stub
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function lookup_unsized (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : v
end
module CreusotContracts_Logic_Fmap_Impl0_LookupUnsized_Interface
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function lookup_unsized (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : v
  val lookup_unsized (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : v
    ensures { result = lookup_unsized self k }
    
end
module CreusotContracts_Logic_Fmap_Impl0_LookupUnsized
  type k
  type v
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = v
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Option_Option_Type.t_option v
  clone CreusotContracts_Util_Unwrap_Stub as Unwrap0 with
    type t = v,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Get_Stub as Get0 with
    type k = k,
    type v = v
  function lookup_unsized (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : v =
    [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 61 8 61 27] Unwrap0.unwrap (Get0.get self k)
  val lookup_unsized (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : v
    ensures { result = lookup_unsized self k }
    
end
module CreusotContracts_Logic_Fmap_Impl0_Lookup_Stub
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function lookup [@inline:trivial] (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : v
end
module CreusotContracts_Logic_Fmap_Impl0_Lookup_Interface
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function lookup [@inline:trivial] (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : v
  val lookup [@inline:trivial] (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : v
    ensures { result = lookup self k }
    
end
module CreusotContracts_Logic_Fmap_Impl0_Lookup
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized_Stub as LookupUnsized0 with
    type k = k,
    type v = v
  function lookup [@inline:trivial] (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : v =
    [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 71 9 71 31] LookupUnsized0.lookup_unsized self k
  val lookup [@inline:trivial] (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : v
    ensures { result = lookup self k }
    
end
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type t_nonnull 't =
    | C_NonNull opaque_ptr
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_unique 't =
    | C_Unique (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (Core_Marker_PhantomData_Type.t_phantomdata 't)
    
end
module Alloc_Boxed_Box_Type
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  type t_box 't 'a =
    | C_Box (Core_Ptr_Unique_Unique_Type.t_unique 't) 'a
    
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
    
end
module CargoDir_LinkedList_Impl0_WfToken_Stub
  type t
  use prelude.Int
  use prelude.Ghost
  use seq.Seq
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  predicate wf_token [#"../src/lib.rs" 248 8 248 41] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int)
    
end
module CargoDir_LinkedList_Impl0_WfToken_Interface
  type t
  use prelude.Int
  use prelude.Ghost
  use seq.Seq
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  predicate wf_token [#"../src/lib.rs" 248 8 248 41] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int)
    
  val wf_token [#"../src/lib.rs" 248 8 248 41] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : bool
    requires {[#"../src/lib.rs" 247 19 247 48] i >= 0 /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self))}
    ensures { result = wf_token self i }
    
end
module CargoDir_LinkedList_Impl0_WfToken
  type t
  use prelude.Int
  use prelude.Ghost
  use seq.Seq
  use prelude.Opaque
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_NextOf_Stub as NextOf0 with
    type t = t,
    axiom .
  clone CargoDir_LinkedList_Impl0_PrevOf_Stub as PrevOf0 with
    type t = t,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup_Stub as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic_Stub as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  predicate wf_token [#"../src/lib.rs" 248 8 248 41] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int)
    
   =
    [#"../src/lib.rs" 245 8 245 20] Contains0.contains (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token self)) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) i) /\ CargoDir_LinkedList_Node_Type.node_prev (Lookup0.lookup (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token self)) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) i)) = PrevOf0.prev_of self i /\ CargoDir_LinkedList_Node_Type.node_next (Lookup0.lookup (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token self)) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) i)) = NextOf0.next_of self i
  val wf_token [#"../src/lib.rs" 248 8 248 41] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : bool
    requires {[#"../src/lib.rs" 247 19 247 48] i >= 0 /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self))}
    ensures { result = wf_token self i }
    
end
module CargoDir_LinkedList_Impl0_WfToken_Impl
  type t
  use prelude.Int
  use prelude.Ghost
  use seq.Seq
  use map.Map
  use prelude.Opaque
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Util_Unwrap_Interface as Unwrap0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv1.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv1.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv2.inv
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized as LookupUnsized0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get,
    function Unwrap0.unwrap = Unwrap0.unwrap,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv4.inv
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_NextOf as NextOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_PrevOf as PrevOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized
  let rec ghost predicate wf_token [#"../src/lib.rs" 248 8 248 41] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int)
    requires {[#"../src/lib.rs" 247 19 247 48] i >= 0 /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self))}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../src/lib.rs" 245 8 245 20] (let a' = ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token self) in let b' = IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) i in Contains0.contains a' b') && (let b = PrevOf0.prev_of self i in let a = CargoDir_LinkedList_Node_Type.node_prev (let a' = ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token self) in let b' = IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) i in Lookup0.lookup a' b') in pure {a = b}) && (let b = NextOf0.next_of self i in let a = CargoDir_LinkedList_Node_Type.node_next (let a' = ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token self) in let b' = IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) i in Lookup0.lookup a' b') in pure {a = b})
end
module CargoDir_LinkedList_Impl0_Invariant_Stub
  type t
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  predicate invariant' [#"../src/lib.rs" 256 8 256 38] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
end
module CargoDir_LinkedList_Impl0_Invariant_Interface
  type t
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  predicate invariant' [#"../src/lib.rs" 256 8 256 38] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  val invariant' [#"../src/lib.rs" 256 8 256 38] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) : bool
    ensures { result = invariant' self }
    
end
module CargoDir_LinkedList_Impl0_Invariant
  type t
  use prelude.Int
  use prelude.Ghost
  use seq.Seq
  use prelude.Opaque
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Stub as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic_Stub as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Stub as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_WfToken_Stub as WfToken0 with
    type t = t,
    axiom .
  predicate invariant' [#"../src/lib.rs" 256 8 256 38] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) =
    [#"../src/lib.rs" 257 12 266 13] (forall i : int . 0 <= i /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self)) -> WfToken0.wf_token self i) /\ (if Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self)) = 0 then
      CargoDir_LinkedList_LinkedList_Type.linkedlist_head self = NullLogic0.null_logic () /\ CargoDir_LinkedList_LinkedList_Type.linkedlist_tail self = NullLogic0.null_logic ()
    else
      CargoDir_LinkedList_LinkedList_Type.linkedlist_head self = IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) 0 /\ CargoDir_LinkedList_LinkedList_Type.linkedlist_tail self = IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self)) - 1)
    )
  val invariant' [#"../src/lib.rs" 256 8 256 38] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) : bool
    ensures { result = invariant' self }
    
end
module CargoDir_LinkedList_Impl0_Model_Stub
  type t
  use seq.Seq
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  function model [#"../src/lib.rs" 271 8 271 36] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) : Seq.seq t
end
module CargoDir_LinkedList_Impl0_Model_Interface
  type t
  use seq.Seq
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  function model [#"../src/lib.rs" 271 8 271 36] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) : Seq.seq t
  val model [#"../src/lib.rs" 271 8 271 36] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) : Seq.seq t
    ensures { result = model self }
    
end
module CargoDir_LinkedList_Impl0_Model
  type t
  use seq.Seq
  use prelude.Ghost
  use prelude.Int
  use prelude.Mapping
  use prelude.Opaque
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup_Stub as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic_Stub as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  function model [#"../src/lib.rs" 271 8 271 36] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) : Seq.seq t
   =
    [#"../src/lib.rs" 273 16 274 77] Seq.create (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self))) (Mapping.from_fn (fun (i : int) -> CargoDir_LinkedList_Node_Type.node_data (Lookup0.lookup (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token self)) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) i))))
  val model [#"../src/lib.rs" 271 8 271 36] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) : Seq.seq t
    ensures { result = model self }
    
end
module Core_Ptr_Null_Interface
  type t
  use prelude.Opaque
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Stub as AddrLogic0 with
    type t = t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = t
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Stub as NullLogic0 with
    type t = t,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  val null (_1 : ()) : opaque_ptr
    ensures { [#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 168 22 168 59] result = NullLogic0.null_logic () }
    
end
module CreusotContracts_Logic_Fmap_Impl0_Len_Stub
  type k
  type v
  use prelude.Int
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  function len (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : int
end
module CreusotContracts_Logic_Fmap_Impl0_Len_Interface
  type k
  type v
  use prelude.Int
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  function len (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : int
  val len (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : int
    requires {[#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 13 15 13 19] Inv0.inv self}
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 12 14 12 25] result >= 0 }
    ensures { result = len self }
    
  axiom len_spec : forall self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v . ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 13 15 13 19] Inv0.inv self) -> ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 12 14 12 25] len self >= 0)
end
module CreusotContracts_Logic_Fmap_Impl0_Len
  type k
  type v
  use prelude.Int
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  function len (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : int
  val len (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : int
    requires {[#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 13 15 13 19] Inv0.inv self}
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 12 14 12 25] result >= 0 }
    ensures { result = len self }
    
  axiom len_spec : forall self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v . ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 13 15 13 19] Inv0.inv self) -> ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 12 14 12 25] len self >= 0)
end
module CreusotContracts_Logic_Fmap_Impl0_Empty_Stub
  type k
  type v
  use map.Const
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  function empty (_1 : ()) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
end
module CreusotContracts_Logic_Fmap_Impl0_Empty_Interface
  type k
  type v
  use map.Const
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  function empty (_1 : ()) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  val empty (_1 : ()) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 83 14 83 31] Len0.len result = 0 }
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 84 14 84 49] View0.view result = Const.const (Core_Option_Option_Type.C_None) }
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 85 4 85 26] Inv0.inv result }
    ensures { result = empty _1 }
    
  axiom empty_spec : forall _1 : () . ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 85 4 85 26] Inv0.inv (empty _1)) && ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 84 14 84 49] View0.view (empty _1) = Const.const (Core_Option_Option_Type.C_None)) && ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 83 14 83 31] Len0.len (empty _1) = 0)
end
module CreusotContracts_Logic_Fmap_Impl0_Empty
  type k
  type v
  use map.Const
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  function empty (_1 : ()) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  val empty (_1 : ()) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 83 14 83 31] Len0.len result = 0 }
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 84 14 84 49] View0.view result = Const.const (Core_Option_Option_Type.C_None) }
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 85 4 85 26] Inv0.inv result }
    ensures { result = empty _1 }
    
  axiom empty_spec : forall _1 : () . ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 85 4 85 26] Inv0.inv (empty _1)) && ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 84 14 84 49] View0.view (empty _1) = Const.const (Core_Option_Option_Type.C_None)) && ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 83 14 83 31] Len0.len (empty _1) = 0)
end
module CreusotContracts_GhostPtr_Impl1_New_Interface
  type t
  use map.Map
  use prelude.Opaque
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option t)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv1.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t
  clone CreusotContracts_Logic_Fmap_Impl0_Empty_Stub as Empty0 with
    type k = opaque_ptr,
    type v = t,
    function Len0.len = Len0.len,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv1.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t
  val new (_1 : ()) : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t
    ensures { [#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 27 14 27 38] ShallowModel0.shallow_model result = Empty0.empty () }
    ensures { [#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 28 4 28 24] Inv0.inv result }
    
end
module CargoDir_LinkedList_Impl0_New_Interface
  type t
  use seq.Seq
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone CargoDir_LinkedList_Impl0_Model_Stub as Model0 with
    type t = t
  clone CargoDir_LinkedList_Impl0_Invariant_Stub as Invariant0 with
    type t = t
  val new [#"../src/lib.rs" 292 8 292 28] (_1 : ()) : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
    ensures { [#"../src/lib.rs" 290 18 290 36] Invariant0.invariant' result }
    ensures { [#"../src/lib.rs" 291 18 291 46] Model0.model result = Seq.empty  }
    ensures { [#"../src/lib.rs" 292 24 292 28] Inv0.inv result }
    
end
module CargoDir_LinkedList_Impl0_New
  type t
  use seq.Seq
  use prelude.Ghost
  use prelude.Opaque
  use map.Map
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv5.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Util_Unwrap_Interface as Unwrap0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv2.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv2.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv3.inv
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_NextOf as NextOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_PrevOf as PrevOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized as LookupUnsized0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get,
    function Unwrap0.unwrap = Unwrap0.unwrap,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv5.inv
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized
  clone CargoDir_LinkedList_Impl0_WfToken as WfToken0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Contains0.contains = Contains0.contains,
    function Lookup0.lookup = Lookup0.lookup,
    function PrevOf0.prev_of = PrevOf0.prev_of,
    function NextOf0.next_of = NextOf0.next_of,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Interface as Len0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Empty_Interface as Empty0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Len0.len = Len0.len,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv2.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CargoDir_LinkedList_Impl0_Invariant as Invariant0 with
    type t = t,
    predicate WfToken0.wf_token = WfToken0.wf_token,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CargoDir_LinkedList_Impl0_Model as Model0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Lookup0.lookup = Lookup0.lookup
  clone CreusotContracts_GhostPtr_Impl1_New_Interface as New0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Empty0.empty = Empty0.empty,
    predicate Inv0.inv = Inv1.inv,
    function Len0.len = Len0.len,
    function View0.view = View0.view,
    predicate Inv1.inv = Inv2.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv2.inv = Inv3.inv
  clone Core_Ptr_Null_Interface as Null0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  let rec cfg new [#"../src/lib.rs" 292 8 292 28] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
    ensures { [#"../src/lib.rs" 290 18 290 36] Invariant0.invariant' result }
    ensures { [#"../src/lib.rs" 291 18 291 46] Model0.model result = Seq.empty  }
    ensures { [#"../src/lib.rs" 292 24 292 28] Inv0.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t;
  var this : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t;
  var _4 : opaque_ptr;
  var _5 : opaque_ptr;
  var _6 : Ghost.ghost_ty (Seq.seq opaque_ptr);
  var _8 : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t);
  {
    goto BB0
  }
  BB0 {
    _4 <- ([#"../src/lib.rs" 294 22 294 33] Null0.null ());
    goto BB1
  }
  BB1 {
    _5 <- ([#"../src/lib.rs" 295 22 295 33] Null0.null ());
    goto BB2
  }
  BB2 {
    _6 <- ([#"../src/lib.rs" 296 22 296 37] Ghost.new (Seq.empty ));
    goto BB3
  }
  BB3 {
    _8 <- ([#"../src/lib.rs" 297 23 297 43] New0.new ());
    goto BB4
  }
  BB4 {
    this <- CargoDir_LinkedList_LinkedList_Type.C_LinkedList _4 _5 _6 _8;
    _4 <- any opaque_ptr;
    _5 <- any opaque_ptr;
    _6 <- any Ghost.ghost_ty (Seq.seq opaque_ptr);
    _8 <- any CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t);
    assert { [@expl:assertion] [#"../src/lib.rs" 299 26 299 57] Seq.(==) (Model0.model this) (Seq.empty ) };
    _0 <- this;
    this <- any CargoDir_LinkedList_LinkedList_Type.t_linkedlist t;
    return _0
  }
  
end
module CreusotContracts_Resolve_Resolve_Resolve_Stub
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Resolve_Resolve_Resolve_Interface
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Resolve_Resolve
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Util_Impl0_MakeSized_Stub
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  function make_sized (self : t) : t
end
module CreusotContracts_Util_Impl0_MakeSized_Interface
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  function make_sized (self : t) : t
  val make_sized (self : t) : t
    requires {[#"../../../../creusot/creusot-contracts/src/util.rs" 16 18 16 22] Inv0.inv self}
    ensures { [#"../../../../creusot/creusot-contracts/src/util.rs" 15 14 15 29] result = self }
    ensures { [#"../../../../creusot/creusot-contracts/src/util.rs" 16 4 16 39] Inv1.inv result }
    ensures { result = make_sized self }
    
  axiom make_sized_spec : forall self : t . ([#"../../../../creusot/creusot-contracts/src/util.rs" 16 18 16 22] Inv0.inv self) -> ([#"../../../../creusot/creusot-contracts/src/util.rs" 16 4 16 39] Inv1.inv (make_sized self)) && ([#"../../../../creusot/creusot-contracts/src/util.rs" 15 14 15 29] make_sized self = self)
end
module CreusotContracts_Util_Impl0_MakeSized
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  function make_sized (self : t) : t
  val make_sized (self : t) : t
    requires {[#"../../../../creusot/creusot-contracts/src/util.rs" 16 18 16 22] Inv0.inv self}
    ensures { [#"../../../../creusot/creusot-contracts/src/util.rs" 15 14 15 29] result = self }
    ensures { [#"../../../../creusot/creusot-contracts/src/util.rs" 16 4 16 39] Inv1.inv result }
    ensures { result = make_sized self }
    
  axiom make_sized_spec : forall self : t . ([#"../../../../creusot/creusot-contracts/src/util.rs" 16 18 16 22] Inv0.inv self) -> ([#"../../../../creusot/creusot-contracts/src/util.rs" 16 4 16 39] Inv1.inv (make_sized self)) && ([#"../../../../creusot/creusot-contracts/src/util.rs" 15 14 15 29] make_sized self = self)
end
module CreusotContracts_Logic_Fmap_Impl0_Insert_Stub
  type k
  type v
  use map.Map
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = v
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = v
  clone CreusotContracts_Util_Impl0_MakeSized_Stub as MakeSized0 with
    type t = v,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  function insert (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) (v : v) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    
end
module CreusotContracts_Logic_Fmap_Impl0_Insert_Interface
  type k
  type v
  use map.Map
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = v
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = v
  clone CreusotContracts_Util_Impl0_MakeSized_Stub as MakeSized0 with
    type t = v,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  function insert (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) (v : v) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    
  val insert (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) (v : v) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    requires {[#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 38 18 38 22] Inv0.inv self}
    requires {[#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 38 24 38 25] Inv1.inv k}
    requires {[#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 38 30 38 31] Inv2.inv v}
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 35 14 35 71] View0.view result = Map.set (View0.view self) k (Core_Option_Option_Type.C_Some (MakeSized0.make_sized v)) }
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 36 4 36 63] Contains0.contains self k -> Len0.len result = Len0.len self }
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 37 4 37 68] not Contains0.contains self k -> Len0.len result = Len0.len self + 1 }
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 38 4 38 43] Inv0.inv result }
    ensures { result = insert self k v }
    
  axiom insert_spec : forall self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v, k : k, v : v . ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 38 18 38 22] Inv0.inv self) -> ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 38 24 38 25] Inv1.inv k) -> ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 38 30 38 31] Inv2.inv v) -> ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 38 4 38 43] Inv0.inv (insert self k v)) && ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 37 4 37 68] not Contains0.contains self k -> Len0.len (insert self k v) = Len0.len self + 1) && ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 36 4 36 63] Contains0.contains self k -> Len0.len (insert self k v) = Len0.len self) && ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 35 14 35 71] View0.view (insert self k v) = Map.set (View0.view self) k (Core_Option_Option_Type.C_Some (MakeSized0.make_sized v)))
end
module CreusotContracts_Logic_Fmap_Impl0_Insert
  type k
  type v
  use map.Map
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = v
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = v
  clone CreusotContracts_Util_Impl0_MakeSized_Stub as MakeSized0 with
    type t = v,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  function insert (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) (v : v) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    
  val insert (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) (v : v) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    requires {[#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 38 18 38 22] Inv0.inv self}
    requires {[#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 38 24 38 25] Inv1.inv k}
    requires {[#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 38 30 38 31] Inv2.inv v}
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 35 14 35 71] View0.view result = Map.set (View0.view self) k (Core_Option_Option_Type.C_Some (MakeSized0.make_sized v)) }
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 36 4 36 63] Contains0.contains self k -> Len0.len result = Len0.len self }
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 37 4 37 68] not Contains0.contains self k -> Len0.len result = Len0.len self + 1 }
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 38 4 38 43] Inv0.inv result }
    ensures { result = insert self k v }
    
  axiom insert_spec : forall self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v, k : k, v : v . ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 38 18 38 22] Inv0.inv self) -> ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 38 24 38 25] Inv1.inv k) -> ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 38 30 38 31] Inv2.inv v) -> ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 38 4 38 43] Inv0.inv (insert self k v)) && ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 37 4 37 68] not Contains0.contains self k -> Len0.len (insert self k v) = Len0.len self + 1) && ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 36 4 36 63] Contains0.contains self k -> Len0.len (insert self k v) = Len0.len self) && ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 35 14 35 71] View0.view (insert self k v) = Map.set (View0.view self) k (Core_Option_Option_Type.C_Some (MakeSized0.make_sized v)))
end
module CreusotContracts_GhostPtr_Impl1_PtrFromBox_Interface
  type t
  use prelude.Borrow
  use prelude.Opaque
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option t)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = t
  clone CreusotContracts_Util_Impl0_MakeSized_Stub as MakeSized0 with
    type t = t,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv2.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = opaque_ptr
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Logic_Fmap_Impl0_Insert_Stub as Insert0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv3.inv,
    predicate Inv2.inv = Inv4.inv,
    function View0.view = View0.view,
    function MakeSized0.make_sized = MakeSized0.make_sized,
    function Contains0.contains = Contains0.contains,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv3.inv = Inv5.inv,
    predicate Inv4.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t)
  val ptr_from_box (self : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t)) (val' : t) : opaque_ptr
    requires {[#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 57 29 57 33] Inv0.inv self}
    requires {[#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 57 35 57 38] Inv1.inv val'}
    ensures { [#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 53 4 53 42] not Contains0.contains (ShallowModel0.shallow_model ( * self)) result }
    ensures { [#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 56 14 56 55] ShallowModel0.shallow_model ( ^ self) = Insert0.insert (ShallowModel0.shallow_model ( * self)) result val' }
    
end
module CargoDir_LinkedList_Impl0_Singleton_Interface
  type t
  use seq.Seq
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone CargoDir_LinkedList_Impl0_Model_Stub as Model0 with
    type t = t
  clone CargoDir_LinkedList_Impl0_Invariant_Stub as Invariant0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  val singleton [#"../src/lib.rs" 305 8 305 38] (v : t) : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
    requires {[#"../src/lib.rs" 305 25 305 26] Inv0.inv v}
    ensures { [#"../src/lib.rs" 303 18 303 36] Invariant0.invariant' result }
    ensures { [#"../src/lib.rs" 304 18 304 58] Seq.(==) (Model0.model result) (Seq.singleton v) }
    ensures { [#"../src/lib.rs" 305 34 305 38] Inv1.inv result }
    
end
module CargoDir_LinkedList_Impl0_Singleton
  type t
  use prelude.Opaque
  use prelude.Borrow
  use seq.Seq
  use prelude.Ghost
  use map.Map
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Util_Unwrap_Interface as Unwrap0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv6.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv3.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv3.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv4.inv
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized as LookupUnsized0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get,
    function Unwrap0.unwrap = Unwrap0.unwrap,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv6.inv
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_NextOf as NextOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_PrevOf as PrevOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = opaque_ptr
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = opaque_ptr,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized
  clone CargoDir_LinkedList_Impl0_WfToken as WfToken0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Contains0.contains = Contains0.contains,
    function Lookup0.lookup = Lookup0.lookup,
    function PrevOf0.prev_of = PrevOf0.prev_of,
    function NextOf0.next_of = NextOf0.next_of,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = t
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = t,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Util_Impl0_MakeSized_Interface as MakeSized0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv8.inv,
    predicate Inv1.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Interface as Len0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Insert_Interface as Insert0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv7.inv,
    predicate Inv2.inv = Inv8.inv,
    function View0.view = View0.view,
    function MakeSized0.make_sized = MakeSized0.make_sized,
    function Contains0.contains = Contains0.contains,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv3.inv = Inv4.inv,
    predicate Inv4.inv = Inv6.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Empty_Interface as Empty0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Len0.len = Len0.len,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv3.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CargoDir_LinkedList_Impl0_Model as Model0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Lookup0.lookup = Lookup0.lookup
  clone CargoDir_LinkedList_Impl0_Invariant as Invariant0 with
    type t = t,
    predicate WfToken0.wf_token = WfToken0.wf_token,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl1_PtrFromBox_Interface as PtrFromBox0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv5.inv,
    predicate Inv1.inv = Inv6.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function Insert0.insert = Insert0.insert,
    predicate Inv2.inv = Inv3.inv,
    predicate Inv3.inv = Inv7.inv,
    predicate Inv4.inv = Inv8.inv,
    function View0.view = View0.view,
    function MakeSized0.make_sized = MakeSized0.make_sized,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv5.inv = Inv4.inv
  clone Core_Ptr_Null_Interface as Null0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_GhostPtr_Impl1_New_Interface as New0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Empty0.empty = Empty0.empty,
    predicate Inv0.inv = Inv0.inv,
    function Len0.len = Len0.len,
    function View0.view = View0.view,
    predicate Inv1.inv = Inv3.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv2.inv = Inv4.inv
  let rec cfg singleton [#"../src/lib.rs" 305 8 305 38] [@cfg:stackify] [@cfg:subregion_analysis] (v : t) : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
    requires {[#"../src/lib.rs" 305 25 305 26] Inv1.inv v}
    ensures { [#"../src/lib.rs" 303 18 303 36] Invariant0.invariant' result }
    ensures { [#"../src/lib.rs" 304 18 304 58] Seq.(==) (Model0.model result) (Seq.singleton v) }
    ensures { [#"../src/lib.rs" 305 34 305 38] Inv2.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t;
  var v : t = v;
  var token : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t);
  var node : CargoDir_LinkedList_Node_Type.t_node t;
  var _7 : opaque_ptr;
  var _8 : opaque_ptr;
  var ptr : opaque_ptr;
  var _10 : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
  var _15 : Ghost.ghost_ty (Seq.seq opaque_ptr);
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    token <- ([#"../src/lib.rs" 307 28 307 48] New0.new ());
    goto BB2
  }
  BB2 {
    _7 <- ([#"../src/lib.rs" 310 22 310 33] Null0.null ());
    goto BB3
  }
  BB3 {
    _8 <- ([#"../src/lib.rs" 311 22 311 33] Null0.null ());
    goto BB4
  }
  BB4 {
    node <- CargoDir_LinkedList_Node_Type.C_Node v _7 _8;
    v <- any t;
    _7 <- any opaque_ptr;
    _8 <- any opaque_ptr;
    goto BB5
  }
  BB5 {
    _10 <- Borrow.borrow_mut token;
    token <-  ^ _10;
    assume { Inv0.inv ( ^ _10) };
    goto BB6
  }
  BB6 {
    ptr <- ([#"../src/lib.rs" 313 22 313 56] PtrFromBox0.ptr_from_box _10 node);
    _10 <- any borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
    node <- any CargoDir_LinkedList_Node_Type.t_node t;
    goto BB7
  }
  BB7 {
    assume { Resolve0.resolve ptr };
    _15 <- ([#"../src/lib.rs" 317 22 317 46] Ghost.new (Seq.singleton ptr));
    goto BB8
  }
  BB8 {
    _0 <- CargoDir_LinkedList_LinkedList_Type.C_LinkedList ptr ptr _15 token;
    _15 <- any Ghost.ghost_ty (Seq.seq opaque_ptr);
    token <- any CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t);
    goto BB9
  }
  BB9 {
    goto BB10
  }
  BB10 {
    return _0
  }
  
end
module CreusotContracts_Logic_Fmap_Impl0_Subset_Stub
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function subset (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : bool
    
end
module CreusotContracts_Logic_Fmap_Impl0_Subset_Interface
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function subset (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : bool
    
  val subset (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : bool
    ensures { result = subset self other }
    
end
module CreusotContracts_Logic_Fmap_Impl0_Subset
  type k
  type v
  use Core_Option_Option_Type as Core_Option_Option_Type
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Get_Stub as Get0 with
    type k = k,
    type v = v
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = k
  function subset (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : bool
    
   =
    [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 104 8 104 81] forall k : k . Inv0.inv k -> Contains0.contains self k -> Get0.get other k = Get0.get self k
  val subset (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : bool
    ensures { result = subset self other }
    
end
module CreusotContracts_Resolve_Impl1_Resolve_Stub
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve_Interface
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl1_Resolve
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t) =
    [#"../../../../creusot/creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module Core_Ptr_ConstPtr_Impl0_IsNull_Interface
  type t
  use prelude.Opaque
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Stub as AddrLogic0 with
    type t = t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = t
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Stub as NullLogic0 with
    type t = t,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  val is_null (self : opaque_ptr) : bool
    ensures { [#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 159 18 159 65] result = (self = NullLogic0.null_logic ()) }
    
end
module CreusotContracts_Logic_Fmap_Impl0_Remove_Stub
  type k
  type v
  use map.Map
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  function remove (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    
end
module CreusotContracts_Logic_Fmap_Impl0_Remove_Interface
  type k
  type v
  use map.Map
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  function remove (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    
  val remove (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    requires {[#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 47 18 47 22] Inv0.inv self}
    requires {[#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 47 24 47 25] Inv1.inv k}
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 45 14 45 55] View0.view result = Map.set (View0.view self) k (Core_Option_Option_Type.C_None) }
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 46 14 46 84] Len0.len result = (if Contains0.contains self k then
      Len0.len self - 1
    else
      Len0.len self
    ) }
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 47 4 47 37] Inv0.inv result }
    ensures { result = remove self k }
    
  axiom remove_spec : forall self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v, k : k . ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 47 18 47 22] Inv0.inv self) -> ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 47 24 47 25] Inv1.inv k) -> ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 47 4 47 37] Inv0.inv (remove self k)) && ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 46 14 46 84] Len0.len (remove self k) = (if Contains0.contains self k then
    Len0.len self - 1
  else
    Len0.len self
  )) && ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 45 14 45 55] View0.view (remove self k) = Map.set (View0.view self) k (Core_Option_Option_Type.C_None))
end
module CreusotContracts_Logic_Fmap_Impl0_Remove
  type k
  type v
  use map.Map
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  function remove (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    
  val remove (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    requires {[#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 47 18 47 22] Inv0.inv self}
    requires {[#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 47 24 47 25] Inv1.inv k}
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 45 14 45 55] View0.view result = Map.set (View0.view self) k (Core_Option_Option_Type.C_None) }
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 46 14 46 84] Len0.len result = (if Contains0.contains self k then
      Len0.len self - 1
    else
      Len0.len self
    ) }
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 47 4 47 37] Inv0.inv result }
    ensures { result = remove self k }
    
  axiom remove_spec : forall self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v, k : k . ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 47 18 47 22] Inv0.inv self) -> ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 47 24 47 25] Inv1.inv k) -> ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 47 4 47 37] Inv0.inv (remove self k)) && ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 46 14 46 84] Len0.len (remove self k) = (if Contains0.contains self k then
    Len0.len self - 1
  else
    Len0.len self
  )) && ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 45 14 45 55] View0.view (remove self k) = Map.set (View0.view self) k (Core_Option_Option_Type.C_None))
end
module CreusotContracts_GhostPtr_Impl1_PtrToBox_Interface
  type t
  use prelude.Borrow
  use prelude.Opaque
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option t)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv2.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = opaque_ptr
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Logic_Fmap_Impl0_Remove_Stub as Remove0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv3.inv,
    function View0.view = View0.view,
    function Len0.len = Len0.len,
    function Contains0.contains = Contains0.contains,
    function Mk0.mk = Mk0.mk,
    predicate Inv2.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized_Stub as LookupUnsized0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t)
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t
  val ptr_to_box (self : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t)) (ptr : opaque_ptr) : t
    requires {[#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 105 4 105 39] Contains0.contains (ShallowModel0.shallow_model ( * self)) ptr}
    requires {[#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 108 27 108 31] Inv0.inv self}
    ensures { [#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 106 14 106 54] result = LookupUnsized0.lookup_unsized (ShallowModel0.shallow_model ( * self)) ptr }
    ensures { [#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 107 14 107 46] ShallowModel0.shallow_model ( ^ self) = Remove0.remove (ShallowModel0.shallow_model ( * self)) ptr }
    ensures { [#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 108 4 108 57] Inv1.inv result }
    
end
module CreusotContracts_Model_ShallowModel_ShallowModelTy_Type
  type self
  type shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Stub
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Interface
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_ShallowModel_ShallowModel
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl7_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl7_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl7_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy =
    [#"../../../../creusot/creusot-contracts/src/model.rs" 101 8 101 31] ShallowModel0.shallow_model ( * self)
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_GhostPtr_Impl1_PtrAsMut_Interface
  type t
  use prelude.Borrow
  use prelude.Opaque
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv6 with
    type t = t
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option t)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = t
  clone CreusotContracts_Util_Impl0_MakeSized_Stub as MakeSized0 with
    type t = t,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv2.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = opaque_ptr
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = borrowed t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Logic_Fmap_Impl0_Insert_Stub as Insert0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv3.inv,
    predicate Inv2.inv = Inv4.inv,
    function View0.view = View0.view,
    function MakeSized0.make_sized = MakeSized0.make_sized,
    function Contains0.contains = Contains0.contains,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv3.inv = Inv5.inv,
    predicate Inv4.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized_Stub as LookupUnsized0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t)
  clone CreusotContracts_Model_Impl7_ShallowModel_Stub as ShallowModel0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t,
    type ShallowModelTy0.shallowModelTy = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
  val ptr_as_mut (self : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t)) (ptr : opaque_ptr) : borrowed t
    requires {[#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 94 4 94 36] Contains0.contains (ShallowModel0.shallow_model self) ptr}
    requires {[#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 97 27 97 31] Inv0.inv self}
    ensures { [#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 95 14 95 54]  * result = LookupUnsized0.lookup_unsized (ShallowModel1.shallow_model ( * self)) ptr }
    ensures { [#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 96 14 96 55] ShallowModel1.shallow_model ( ^ self) = Insert0.insert (ShallowModel1.shallow_model ( * self)) ptr ( ^ result) }
    ensures { [#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 97 4 97 57] Inv1.inv result }
    
end
module CargoDir_LinkedList_Impl0_PopFront_Interface
  type t
  use prelude.Borrow
  use seq.Seq
  use prelude.Int
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone CargoDir_LinkedList_Impl0_Model_Stub as Model0 with
    type t = t
  clone CargoDir_LinkedList_Impl0_Invariant_Stub as Invariant0 with
    type t = t
  val pop_front [#"../src/lib.rs" 327 8 327 40] (self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)) : t
    requires {[#"../src/lib.rs" 323 19 323 38] Invariant0.invariant' ( * self)}
    requires {[#"../src/lib.rs" 324 19 324 44] Seq.length (Model0.model ( * self)) > 0}
    requires {[#"../src/lib.rs" 327 30 327 34] Inv0.inv self}
    ensures { [#"../src/lib.rs" 325 18 325 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"../src/lib.rs" 326 18 326 88] Seq.(==) (Seq.(++) (Seq.singleton result) (Model0.model ( ^ self))) (Model0.model ( * self)) }
    ensures { [#"../src/lib.rs" 327 39 327 40] Inv1.inv result }
    
end
module CargoDir_LinkedList_Impl0_PopFront
  type t
  use prelude.Borrow
  use prelude.Ghost
  use seq.Seq
  use prelude.Int
  use prelude.Opaque
  use seq_ext.SeqExt
  use map.Map
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial13 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv13.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial12 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv12.inv,
    axiom .
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial11 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv11.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial10 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Util_Unwrap_Interface as Unwrap0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv13.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = opaque_ptr
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = opaque_ptr,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = t
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = t,
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  use seq.Seq
  use prelude.Ghost
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = borrowed (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = borrowed (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Util_Impl0_MakeSized_Interface as MakeSized0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv12.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Interface as Len0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv10.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv10.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv11.inv
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  clone CreusotContracts_Logic_Fmap_Impl0_Insert_Interface as Insert0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv7.inv,
    predicate Inv2.inv = Inv12.inv,
    function View0.view = View0.view,
    function MakeSized0.make_sized = MakeSized0.make_sized,
    function Contains0.contains = Contains0.contains,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv3.inv = Inv11.inv,
    predicate Inv4.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel1 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    type ShallowModelTy0.shallowModelTy = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_NextOf as NextOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_PrevOf as PrevOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized as LookupUnsized0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get,
    function Unwrap0.unwrap = Unwrap0.unwrap,
    predicate Inv0.inv = Inv13.inv,
    predicate Inv1.inv = Inv4.inv
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized
  clone CreusotContracts_Logic_Fmap_Impl0_Remove_Interface as Remove0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv7.inv,
    function View0.view = View0.view,
    function Len0.len = Len0.len,
    function Contains0.contains = Contains0.contains,
    function Mk0.mk = Mk0.mk,
    predicate Inv2.inv = Inv11.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CargoDir_LinkedList_Impl0_WfToken as WfToken0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Contains0.contains = Contains0.contains,
    function Lookup0.lookup = Lookup0.lookup,
    function PrevOf0.prev_of = PrevOf0.prev_of,
    function NextOf0.next_of = NextOf0.next_of,
    axiom .
  clone CargoDir_LinkedList_Impl0_Invariant as Invariant0 with
    type t = t,
    predicate WfToken0.wf_token = WfToken0.wf_token,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve6 with
    type self = CargoDir_LinkedList_Node_Type.t_node t
  clone CargoDir_LinkedList_Impl0_Model as Model0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Lookup0.lookup = Lookup0.lookup
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve5 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = Ghost.ghost_ty (Seq.seq opaque_ptr)
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve3 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = opaque_ptr
  clone Core_Ptr_Null_Interface as Null0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_GhostPtr_Impl1_PtrAsMut_Interface as PtrAsMut0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function Contains0.contains = Contains0.contains,
    predicate Inv0.inv = Inv9.inv,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized,
    function Insert0.insert = Insert0.insert,
    predicate Inv1.inv = Inv2.inv,
    predicate Inv2.inv = Inv10.inv,
    predicate Inv3.inv = Inv7.inv,
    predicate Inv4.inv = Inv12.inv,
    function View0.view = View0.view,
    function MakeSized0.make_sized = MakeSized0.make_sized,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv5.inv = Inv11.inv,
    predicate Inv6.inv = Inv4.inv
  clone CreusotContracts_Logic_Fmap_Impl0_Subset as Subset0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv7.inv,
    function Contains0.contains = Contains0.contains,
    function Get0.get = Get0.get
  clone CreusotContracts_GhostPtr_Impl1_PtrToBox_Interface as PtrToBox0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    predicate Inv0.inv = Inv9.inv,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized,
    function Remove0.remove = Remove0.remove,
    predicate Inv1.inv = Inv4.inv,
    predicate Inv2.inv = Inv10.inv,
    predicate Inv3.inv = Inv7.inv,
    function View0.view = View0.view,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv4.inv = Inv11.inv
  clone Core_Ptr_ConstPtr_Impl0_IsNull_Interface as IsNull0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = ()
  clone CargoDir_Lemmas_MapSetCommute_Interface as MapSetCommute0 with
    type k = opaque_ptr,
    type v = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv7.inv,
    predicate Inv2.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  let rec cfg pop_front [#"../src/lib.rs" 327 8 327 40] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)) : t
    requires {[#"../src/lib.rs" 323 19 323 38] Invariant0.invariant' ( * self)}
    requires {[#"../src/lib.rs" 324 19 324 44] Seq.length (Model0.model ( * self)) > 0}
    requires {[#"../src/lib.rs" 327 30 327 34] Inv3.inv self}
    ensures { [#"../src/lib.rs" 325 18 325 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"../src/lib.rs" 326 18 326 88] Seq.(==) (Seq.(++) (Seq.singleton result) (Model0.model ( ^ self))) (Model0.model ( * self)) }
    ensures { [#"../src/lib.rs" 327 39 327 40] Inv5.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : t;
  var self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) = self;
  var self_ghost_old : Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
  var _8 : ();
  var _9 : bool;
  var node : CargoDir_LinkedList_Node_Type.t_node t;
  var _20 : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
  var _27 : ();
  var _28 : bool;
  var _30 : opaque_ptr;
  var _31 : Ghost.ghost_ty (Seq.seq opaque_ptr);
  var new_head : borrowed (CargoDir_LinkedList_Node_Type.t_node t);
  var _44 : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
  var _46 : opaque_ptr;
  var _47 : Ghost.ghost_ty (Seq.seq opaque_ptr);
  {
    goto BB0
  }
  BB0 {
    self_ghost_old <- ([#"../src/lib.rs" 328 33 328 43] Ghost.new ( * self));
    goto BB1
  }
  BB1 {
    assert { [@expl:type invariant] Inv0.inv self_ghost_old };
    assume { Resolve0.resolve self_ghost_old };
    _8 <- ([#"../src/lib.rs" 329 12 329 62] ());
    assume { Resolve1.resolve _8 };
    _9 <- ([#"../src/lib.rs" 330 15 330 34] IsNull0.is_null (CargoDir_LinkedList_LinkedList_Type.linkedlist_head ( * self)));
    goto BB2
  }
  BB2 {
    switch (_9)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [@expl:type invariant] Inv3.inv self };
    assume { Resolve5.resolve self };
    absurd
  }
  BB4 {
    assert { [@expl:assertion] [#"../src/lib.rs" 333 30 333 55] CargoDir_LinkedList_LinkedList_Type.linkedlist_head ( * self) = IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) 0 };
    assert { [@expl:assertion] [#"../src/lib.rs" 334 30 334 49] Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) > 0 };
    assert { [@expl:assertion] [#"../src/lib.rs" 335 16 335 80] Contains0.contains (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) 0) };
    _20 <- Borrow.borrow_mut (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self));
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c ( ^ _20)) };
    assume { Inv1.inv ( ^ _20) };
    node <- ([#"../src/lib.rs" 336 27 336 59] PtrToBox0.ptr_to_box _20 (CargoDir_LinkedList_LinkedList_Type.linkedlist_head ( * self)));
    _20 <- any borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
    goto BB5
  }
  BB5 {
    assert { [@expl:assertion] [#"../src/lib.rs" 337 16 337 158] forall i : opaque_ptr . Contains0.contains (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token (Ghost.inner self_ghost_old))) i /\ i <> IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) 0 -> Contains0.contains (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) i };
    assert { [@expl:assertion] [#"../src/lib.rs" 338 16 338 131] forall i : int . 1 <= i /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) -> Contains0.contains (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) i) };
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList (CargoDir_LinkedList_Node_Type.node_next node) b c d) };
    _28 <- ([#"../src/lib.rs" 340 19 340 38] IsNull0.is_null (CargoDir_LinkedList_LinkedList_Type.linkedlist_head ( * self)));
    goto BB6
  }
  BB6 {
    switch (_28)
      | False -> goto BB10
      | True -> goto BB7
      end
  }
  BB7 {
    _30 <- ([#"../src/lib.rs" 341 32 341 43] Null0.null ());
    goto BB8
  }
  BB8 {
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a _30 c d) };
    _30 <- any opaque_ptr;
    _31 <- ([#"../src/lib.rs" 342 32 342 78] Ghost.new (SeqExt.subsequence (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) 1 (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))))));
    goto BB9
  }
  BB9 {
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b _31 d) };
    _31 <- any Ghost.ghost_ty (Seq.seq opaque_ptr);
    assume { Resolve4.resolve (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) };
    assert { [@expl:type invariant] Inv3.inv self };
    assume { Resolve5.resolve self };
    _27 <- ();
    goto BB14
  }
  BB10 {
    assert { [@expl:assertion] [#"../src/lib.rs" 344 34 344 53] Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) > 1 };
    assert { [@expl:assertion] [#"../src/lib.rs" 345 20 345 106] Subset0.subset (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token (Ghost.inner self_ghost_old))) };
    assert { [@expl:assertion] [#"../src/lib.rs" 346 34 346 50] WfToken0.wf_token ( * self) 1 };
    assert { [@expl:assertion] [#"../src/lib.rs" 347 20 347 84] Contains0.contains (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) 1) };
    assert { [@expl:assertion] [#"../src/lib.rs" 348 34 348 59] CargoDir_LinkedList_LinkedList_Type.linkedlist_head ( * self) = IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) 1 };
    _44 <- Borrow.borrow_mut (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self));
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c ( ^ _44)) };
    assume { Inv1.inv ( ^ _44) };
    new_head <- ([#"../src/lib.rs" 349 35 349 67] PtrAsMut0.ptr_as_mut _44 (CargoDir_LinkedList_LinkedList_Type.linkedlist_head ( * self)));
    _44 <- any borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
    goto BB11
  }
  BB11 {
    _46 <- ([#"../src/lib.rs" 350 36 350 47] Null0.null ());
    goto BB12
  }
  BB12 {
    new_head <- { new_head with current = (let CargoDir_LinkedList_Node_Type.C_Node a b c =  * new_head in CargoDir_LinkedList_Node_Type.C_Node a b _46) };
    _46 <- any opaque_ptr;
    assume { Resolve2.resolve (CargoDir_LinkedList_Node_Type.node_prev ( * new_head)) };
    assert { [@expl:type invariant] Inv2.inv new_head };
    assume { Resolve3.resolve new_head };
    _47 <- ([#"../src/lib.rs" 351 32 351 78] Ghost.new (SeqExt.subsequence (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) 1 (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))))));
    goto BB13
  }
  BB13 {
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b _47 d) };
    _47 <- any Ghost.ghost_ty (Seq.seq opaque_ptr);
    assume { Resolve4.resolve (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) };
    assert { [@expl:type invariant] Inv3.inv self };
    assume { Resolve5.resolve self };
    assert { [@expl:assertion] [#"../src/lib.rs" 352 20 352 136] forall i : int . 0 <= i /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) /\ WfToken0.wf_token (Ghost.inner self_ghost_old) (i + 1) -> WfToken0.wf_token ( * self) i };
    assert { [@expl:assertion] [#"../src/lib.rs" 353 20 353 102] forall i : int . 1 <= i /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) -> WfToken0.wf_token ( * self) i };
    _27 <- ();
    goto BB14
  }
  BB14 {
    assert { [@expl:assertion] [#"../src/lib.rs" 356 30 356 68] CargoDir_LinkedList_Node_Type.node_data node = Seq.get (Model0.model (Ghost.inner self_ghost_old)) 0 };
    goto BB15
  }
  BB15 {
    _0 <- CargoDir_LinkedList_Node_Type.node_data node;
    node <- (let CargoDir_LinkedList_Node_Type.C_Node a b c = node in CargoDir_LinkedList_Node_Type.C_Node (any t) b c);
    assert { [@expl:type invariant] Inv4.inv node };
    assume { Resolve6.resolve node };
    goto BB16
  }
  BB16 {
    return _0
  }
  
end
module CargoDir_LinkedList_Impl0_PopBack_Interface
  type t
  use prelude.Borrow
  use seq.Seq
  use prelude.Int
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone CargoDir_LinkedList_Impl0_Model_Stub as Model0 with
    type t = t
  clone CargoDir_LinkedList_Impl0_Invariant_Stub as Invariant0 with
    type t = t
  val pop_back [#"../src/lib.rs" 365 8 365 39] (self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)) : t
    requires {[#"../src/lib.rs" 361 19 361 38] Invariant0.invariant' ( * self)}
    requires {[#"../src/lib.rs" 362 19 362 44] Seq.length (Model0.model ( * self)) > 0}
    requires {[#"../src/lib.rs" 365 29 365 33] Inv0.inv self}
    ensures { [#"../src/lib.rs" 363 18 363 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"../src/lib.rs" 364 18 364 88] Seq.(==) (Seq.(++) (Model0.model ( ^ self)) (Seq.singleton result)) (Model0.model ( * self)) }
    ensures { [#"../src/lib.rs" 365 38 365 39] Inv1.inv result }
    
end
module CargoDir_LinkedList_Impl0_PopBack
  type t
  use prelude.Borrow
  use prelude.Ghost
  use prelude.Opaque
  use seq.Seq
  use prelude.Int
  use seq_ext.SeqExt
  use map.Map
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial13 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv13.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial12 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv12.inv,
    axiom .
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial11 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv11.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial10 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Util_Unwrap_Interface as Unwrap0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv13.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = opaque_ptr
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = opaque_ptr,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = t
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = t,
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  use seq.Seq
  use prelude.Ghost
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = borrowed (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = borrowed (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Util_Impl0_MakeSized_Interface as MakeSized0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv12.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Interface as Len0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv10.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv10.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv11.inv
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  clone CreusotContracts_Logic_Fmap_Impl0_Insert_Interface as Insert0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv7.inv,
    predicate Inv2.inv = Inv12.inv,
    function View0.view = View0.view,
    function MakeSized0.make_sized = MakeSized0.make_sized,
    function Contains0.contains = Contains0.contains,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv3.inv = Inv11.inv,
    predicate Inv4.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel1 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    type ShallowModelTy0.shallowModelTy = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_NextOf as NextOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_PrevOf as PrevOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized as LookupUnsized0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get,
    function Unwrap0.unwrap = Unwrap0.unwrap,
    predicate Inv0.inv = Inv13.inv,
    predicate Inv1.inv = Inv4.inv
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized
  clone CreusotContracts_Logic_Fmap_Impl0_Remove_Interface as Remove0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv7.inv,
    function View0.view = View0.view,
    function Len0.len = Len0.len,
    function Contains0.contains = Contains0.contains,
    function Mk0.mk = Mk0.mk,
    predicate Inv2.inv = Inv11.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CargoDir_LinkedList_Impl0_Model as Model0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Lookup0.lookup = Lookup0.lookup
  clone CargoDir_LinkedList_Impl0_WfToken as WfToken0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Contains0.contains = Contains0.contains,
    function Lookup0.lookup = Lookup0.lookup,
    function PrevOf0.prev_of = PrevOf0.prev_of,
    function NextOf0.next_of = NextOf0.next_of,
    axiom .
  clone CargoDir_LinkedList_Impl0_Invariant as Invariant0 with
    type t = t,
    predicate WfToken0.wf_token = WfToken0.wf_token,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve6 with
    type self = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve5 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = Ghost.ghost_ty (Seq.seq opaque_ptr)
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve3 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = opaque_ptr
  clone Core_Ptr_Null_Interface as Null0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_GhostPtr_Impl1_PtrAsMut_Interface as PtrAsMut0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function Contains0.contains = Contains0.contains,
    predicate Inv0.inv = Inv9.inv,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized,
    function Insert0.insert = Insert0.insert,
    predicate Inv1.inv = Inv2.inv,
    predicate Inv2.inv = Inv10.inv,
    predicate Inv3.inv = Inv7.inv,
    predicate Inv4.inv = Inv12.inv,
    function View0.view = View0.view,
    function MakeSized0.make_sized = MakeSized0.make_sized,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv5.inv = Inv11.inv,
    predicate Inv6.inv = Inv4.inv
  clone CreusotContracts_Logic_Fmap_Impl0_Subset as Subset0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv7.inv,
    function Contains0.contains = Contains0.contains,
    function Get0.get = Get0.get
  clone CreusotContracts_GhostPtr_Impl1_PtrToBox_Interface as PtrToBox0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    predicate Inv0.inv = Inv9.inv,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized,
    function Remove0.remove = Remove0.remove,
    predicate Inv1.inv = Inv4.inv,
    predicate Inv2.inv = Inv10.inv,
    predicate Inv3.inv = Inv7.inv,
    function View0.view = View0.view,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv4.inv = Inv11.inv
  clone Core_Ptr_ConstPtr_Impl0_IsNull_Interface as IsNull0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = ()
  clone CargoDir_Lemmas_MapSetCommute_Interface as MapSetCommute0 with
    type k = opaque_ptr,
    type v = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv7.inv,
    predicate Inv2.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  let rec cfg pop_back [#"../src/lib.rs" 365 8 365 39] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)) : t
    requires {[#"../src/lib.rs" 361 19 361 38] Invariant0.invariant' ( * self)}
    requires {[#"../src/lib.rs" 362 19 362 44] Seq.length (Model0.model ( * self)) > 0}
    requires {[#"../src/lib.rs" 365 29 365 33] Inv3.inv self}
    ensures { [#"../src/lib.rs" 363 18 363 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"../src/lib.rs" 364 18 364 88] Seq.(==) (Seq.(++) (Model0.model ( ^ self)) (Seq.singleton result)) (Model0.model ( * self)) }
    ensures { [#"../src/lib.rs" 365 38 365 39] Inv5.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : t;
  var self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) = self;
  var self_ghost_old : Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
  var _8 : ();
  var _9 : bool;
  var node : CargoDir_LinkedList_Node_Type.t_node t;
  var _14 : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
  var _21 : ();
  var _22 : bool;
  var _24 : opaque_ptr;
  var new_tail : borrowed (CargoDir_LinkedList_Node_Type.t_node t);
  var _36 : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
  var _38 : opaque_ptr;
  var _39 : Ghost.ghost_ty (Seq.seq opaque_ptr);
  {
    goto BB0
  }
  BB0 {
    self_ghost_old <- ([#"../src/lib.rs" 366 33 366 43] Ghost.new ( * self));
    goto BB1
  }
  BB1 {
    assert { [@expl:type invariant] Inv0.inv self_ghost_old };
    assume { Resolve0.resolve self_ghost_old };
    _8 <- ([#"../src/lib.rs" 367 12 367 62] ());
    assume { Resolve1.resolve _8 };
    _9 <- ([#"../src/lib.rs" 368 15 368 34] IsNull0.is_null (CargoDir_LinkedList_LinkedList_Type.linkedlist_tail ( * self)));
    goto BB2
  }
  BB2 {
    switch (_9)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [@expl:type invariant] Inv3.inv self };
    assume { Resolve5.resolve self };
    absurd
  }
  BB4 {
    _14 <- Borrow.borrow_mut (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self));
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c ( ^ _14)) };
    assume { Inv1.inv ( ^ _14) };
    node <- ([#"../src/lib.rs" 371 27 371 59] PtrToBox0.ptr_to_box _14 (CargoDir_LinkedList_LinkedList_Type.linkedlist_tail ( * self)));
    _14 <- any borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
    goto BB5
  }
  BB5 {
    assert { [@expl:assertion] [#"../src/lib.rs" 372 16 372 176] forall i : opaque_ptr . Contains0.contains (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token (Ghost.inner self_ghost_old))) i /\ i <> IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) - 1) -> Contains0.contains (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) i };
    assert { [@expl:assertion] [#"../src/lib.rs" 373 16 373 135] forall i : int . 0 <= i /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) - 1 -> Contains0.contains (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) i) };
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a (CargoDir_LinkedList_Node_Type.node_prev node) c d) };
    _22 <- ([#"../src/lib.rs" 375 19 375 38] IsNull0.is_null (CargoDir_LinkedList_LinkedList_Type.linkedlist_tail ( * self)));
    goto BB6
  }
  BB6 {
    switch (_22)
      | False -> goto BB9
      | True -> goto BB7
      end
  }
  BB7 {
    _24 <- ([#"../src/lib.rs" 376 32 376 43] Null0.null ());
    goto BB8
  }
  BB8 {
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList _24 b c d) };
    _24 <- any opaque_ptr;
    _21 <- ();
    goto BB12
  }
  BB9 {
    assert { [@expl:assertion] [#"../src/lib.rs" 378 34 378 53] Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) > 1 };
    assert { [@expl:assertion] [#"../src/lib.rs" 379 20 379 106] Subset0.subset (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token (Ghost.inner self_ghost_old))) };
    assert { [@expl:assertion] [#"../src/lib.rs" 380 34 380 68] WfToken0.wf_token ( * self) (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) - 2) };
    assert { [@expl:assertion] [#"../src/lib.rs" 381 20 381 102] Contains0.contains (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) - 2)) };
    assert { [@expl:assertion] [#"../src/lib.rs" 382 34 382 77] CargoDir_LinkedList_LinkedList_Type.linkedlist_tail ( * self) = IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) - 2) };
    _36 <- Borrow.borrow_mut (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self));
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c ( ^ _36)) };
    assume { Inv1.inv ( ^ _36) };
    new_tail <- ([#"../src/lib.rs" 383 35 383 67] PtrAsMut0.ptr_as_mut _36 (CargoDir_LinkedList_LinkedList_Type.linkedlist_tail ( * self)));
    _36 <- any borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
    goto BB10
  }
  BB10 {
    _38 <- ([#"../src/lib.rs" 384 36 384 47] Null0.null ());
    goto BB11
  }
  BB11 {
    new_tail <- { new_tail with current = (let CargoDir_LinkedList_Node_Type.C_Node a b c =  * new_tail in CargoDir_LinkedList_Node_Type.C_Node a _38 c) };
    _38 <- any opaque_ptr;
    assume { Resolve2.resolve (CargoDir_LinkedList_Node_Type.node_next ( * new_tail)) };
    assert { [@expl:type invariant] Inv2.inv new_tail };
    assume { Resolve3.resolve new_tail };
    _21 <- ();
    goto BB12
  }
  BB12 {
    _39 <- ([#"../src/lib.rs" 386 28 386 78] Ghost.new (SeqExt.subsequence (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) 0 (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) - 1)));
    goto BB13
  }
  BB13 {
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b _39 d) };
    _39 <- any Ghost.ghost_ty (Seq.seq opaque_ptr);
    assume { Resolve4.resolve (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) };
    assert { [@expl:type invariant] Inv3.inv self };
    assume { Resolve5.resolve self };
    assert { [@expl:assertion] [#"../src/lib.rs" 387 16 387 129] forall i : int . 0 <= i /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) -> WfToken0.wf_token (Ghost.inner self_ghost_old) i -> WfToken0.wf_token ( * self) i };
    _0 <- CargoDir_LinkedList_Node_Type.node_data node;
    node <- (let CargoDir_LinkedList_Node_Type.C_Node a b c = node in CargoDir_LinkedList_Node_Type.C_Node (any t) b c);
    assert { [@expl:type invariant] Inv4.inv node };
    assume { Resolve6.resolve node };
    goto BB14
  }
  BB14 {
    return _0
  }
  
end
module CreusotContracts_Logic_Fmap_Impl0_Disjoint_Stub
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function disjoint (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : bool
    
end
module CreusotContracts_Logic_Fmap_Impl0_Disjoint_Interface
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function disjoint (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : bool
    
  val disjoint (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : bool
    ensures { result = disjoint self other }
    
end
module CreusotContracts_Logic_Fmap_Impl0_Disjoint
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = k
  function disjoint (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : bool
    
   =
    [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 98 8 98 72] forall k : k . Inv0.inv k -> not Contains0.contains self k \/ not Contains0.contains other k
  val disjoint (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : bool
    ensures { result = disjoint self other }
    
end
module CreusotContracts_Logic_Fmap_Impl0_Union_Stub
  type k
  type v
  use prelude.Int
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = k,
    type v = v
  clone CreusotContracts_Logic_Fmap_Impl0_Get_Stub as Get0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Logic_Fmap_Impl0_Disjoint_Stub as Disjoint0 with
    type k = k,
    type v = v
  function union (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    
end
module CreusotContracts_Logic_Fmap_Impl0_Union_Interface
  type k
  type v
  use prelude.Int
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = k,
    type v = v
  clone CreusotContracts_Logic_Fmap_Impl0_Get_Stub as Get0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Logic_Fmap_Impl0_Disjoint_Stub as Disjoint0 with
    type k = k,
    type v = v
  function union (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    
  val union (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    requires {[#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 110 15 110 35] Disjoint0.disjoint self other}
    requires {[#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 119 17 119 21] Inv0.inv self}
    requires {[#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 119 23 119 28] Inv0.inv other}
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 111 4 117 7] forall k : k . Inv1.inv k -> Get0.get result k = (if Contains0.contains self k then
      Get0.get self k
    else
      if Contains0.contains other k then Get0.get other k else Core_Option_Option_Type.C_None
    ) }
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 118 14 118 54] Len0.len result = Len0.len self + Len0.len other }
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 119 4 119 43] Inv0.inv result }
    ensures { result = union self other }
    
  axiom union_spec : forall self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v, other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v . ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 110 15 110 35] Disjoint0.disjoint self other) -> ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 119 17 119 21] Inv0.inv self) -> ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 119 23 119 28] Inv0.inv other) -> ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 119 4 119 43] Inv0.inv (union self other)) && ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 118 14 118 54] Len0.len (union self other) = Len0.len self + Len0.len other) && ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 111 4 117 7] forall k : k . Inv1.inv k -> Get0.get (union self other) k = (if Contains0.contains self k then
    Get0.get self k
  else
    if Contains0.contains other k then Get0.get other k else Core_Option_Option_Type.C_None
  ))
end
module CreusotContracts_Logic_Fmap_Impl0_Union
  type k
  type v
  use prelude.Int
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = k,
    type v = v
  clone CreusotContracts_Logic_Fmap_Impl0_Get_Stub as Get0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Logic_Fmap_Impl0_Disjoint_Stub as Disjoint0 with
    type k = k,
    type v = v
  function union (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    
  val union (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    requires {[#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 110 15 110 35] Disjoint0.disjoint self other}
    requires {[#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 119 17 119 21] Inv0.inv self}
    requires {[#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 119 23 119 28] Inv0.inv other}
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 111 4 117 7] forall k : k . Inv1.inv k -> Get0.get result k = (if Contains0.contains self k then
      Get0.get self k
    else
      if Contains0.contains other k then Get0.get other k else Core_Option_Option_Type.C_None
    ) }
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 118 14 118 54] Len0.len result = Len0.len self + Len0.len other }
    ensures { [#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 119 4 119 43] Inv0.inv result }
    ensures { result = union self other }
    
  axiom union_spec : forall self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v, other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v . ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 110 15 110 35] Disjoint0.disjoint self other) -> ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 119 17 119 21] Inv0.inv self) -> ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 119 23 119 28] Inv0.inv other) -> ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 119 4 119 43] Inv0.inv (union self other)) && ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 118 14 118 54] Len0.len (union self other) = Len0.len self + Len0.len other) && ([#"../../../../creusot/creusot-contracts/src/logic/fmap.rs" 111 4 117 7] forall k : k . Inv1.inv k -> Get0.get (union self other) k = (if Contains0.contains self k then
    Get0.get self k
  else
    if Contains0.contains other k then Get0.get other k else Core_Option_Option_Type.C_None
  ))
end
module CreusotContracts_GhostPtr_Impl1_Merge_Interface
  type t
  use prelude.Borrow
  use prelude.Opaque
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Logic_Fmap_Impl0_Get_Stub as Get0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = opaque_ptr
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Disjoint_Stub as Disjoint0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Logic_Fmap_Impl0_Union_Stub as Union0 with
    type k = opaque_ptr,
    type v = t,
    function Disjoint0.disjoint = Disjoint0.disjoint,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv3.inv,
    function Get0.get = Get0.get,
    function Contains0.contains = Contains0.contains,
    function Len0.len = Len0.len,
    axiom .
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t)
  val merge (self : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t)) (_other : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t) : ()
    requires {[#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 117 22 117 26] Inv0.inv self}
    requires {[#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 117 28 117 34] Inv1.inv _other}
    ensures { [#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 113 4 113 42] Disjoint0.disjoint (ShallowModel0.shallow_model ( * self)) (ShallowModel0.shallow_model _other) }
    ensures { [#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 116 14 116 49] ShallowModel0.shallow_model ( ^ self) = Union0.union (ShallowModel0.shallow_model ( * self)) (ShallowModel0.shallow_model _other) }
    
end
module CargoDir_LinkedList_Impl0_Append_Interface
  type t
  use prelude.Borrow
  use seq.Seq
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_Model_Stub as Model0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone CargoDir_LinkedList_Impl0_Invariant_Stub as Invariant0 with
    type t = t
  val append [#"../src/lib.rs" 396 8 396 49] (self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)) (other : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) : ()
    requires {[#"../src/lib.rs" 392 19 392 38] Invariant0.invariant' ( * self)}
    requires {[#"../src/lib.rs" 393 19 393 36] Invariant0.invariant' other}
    requires {[#"../src/lib.rs" 396 27 396 31] Inv0.inv self}
    requires {[#"../src/lib.rs" 396 37 396 42] Inv1.inv other}
    ensures { [#"../src/lib.rs" 394 18 394 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"../src/lib.rs" 395 18 395 79] Seq.(==) (Model0.model ( ^ self)) (Seq.(++) (Model0.model ( * self)) (Model0.model other)) }
    
end
module CargoDir_LinkedList_Impl0_Append
  type t
  use prelude.Ghost
  use prelude.Borrow
  use seq.Seq
  use prelude.Opaque
  use prelude.Int
  use map.Map
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial12 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial11 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial10 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = opaque_ptr
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = opaque_ptr,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Util_Unwrap_Interface as Unwrap0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv12.inv,
    predicate Inv1.inv = Inv11.inv,
    axiom .
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv7.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv6.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv6.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv10.inv
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv4.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_NextOf as NextOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv4.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_PrevOf as PrevOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv4.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  use seq.Seq
  use prelude.Ghost
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = borrowed (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = borrowed (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Interface as Len0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Util_Impl0_MakeSized_Interface as MakeSized0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Insert_Interface as Insert0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv8.inv,
    predicate Inv2.inv = Inv9.inv,
    function View0.view = View0.view,
    function MakeSized0.make_sized = MakeSized0.make_sized,
    function Contains0.contains = Contains0.contains,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv3.inv = Inv10.inv,
    predicate Inv4.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized as LookupUnsized0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get,
    function Unwrap0.unwrap = Unwrap0.unwrap,
    predicate Inv0.inv = Inv12.inv,
    predicate Inv1.inv = Inv11.inv
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel1 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    type ShallowModelTy0.shallowModelTy = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Ghost.ghost_ty (borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t))
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Ghost.ghost_ty (borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized
  clone CargoDir_LinkedList_Impl0_Model as Model0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Lookup0.lookup = Lookup0.lookup
  clone CargoDir_LinkedList_Impl0_WfToken as WfToken0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Contains0.contains = Contains0.contains,
    function Lookup0.lookup = Lookup0.lookup,
    function PrevOf0.prev_of = PrevOf0.prev_of,
    function NextOf0.next_of = NextOf0.next_of,
    axiom .
  clone CargoDir_LinkedList_Impl0_Invariant as Invariant0 with
    type t = t,
    predicate WfToken0.wf_token = WfToken0.wf_token,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv4.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Logic_Fmap_Impl0_Subset as Subset0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv8.inv,
    function Contains0.contains = Contains0.contains,
    function Get0.get = Get0.get
  clone CreusotContracts_Logic_Fmap_Impl0_Disjoint as Disjoint0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv8.inv,
    function Contains0.contains = Contains0.contains
  clone CreusotContracts_Logic_Fmap_Impl0_Union_Interface as Union0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Disjoint0.disjoint = Disjoint0.disjoint,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv8.inv,
    function Get0.get = Get0.get,
    function Contains0.contains = Contains0.contains,
    function Len0.len = Len0.len,
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve6 with
    type self = Ghost.ghost_ty (Seq.seq opaque_ptr)
  clone CreusotContracts_GhostPtr_Impl1_Merge_Interface as Merge0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv7.inv,
    predicate Inv1.inv = Inv4.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Disjoint0.disjoint = Disjoint0.disjoint,
    function Union0.union = Union0.union,
    predicate Inv2.inv = Inv6.inv,
    predicate Inv3.inv = Inv8.inv,
    function Get0.get = Get0.get,
    function Contains0.contains = Contains0.contains,
    function Len0.len = Len0.len
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve5 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl1_PtrAsMut_Interface as PtrAsMut0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function Contains0.contains = Contains0.contains,
    predicate Inv0.inv = Inv7.inv,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized,
    function Insert0.insert = Insert0.insert,
    predicate Inv1.inv = Inv5.inv,
    predicate Inv2.inv = Inv6.inv,
    predicate Inv3.inv = Inv8.inv,
    predicate Inv4.inv = Inv9.inv,
    function View0.view = View0.view,
    function MakeSized0.make_sized = MakeSized0.make_sized,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv5.inv = Inv10.inv,
    predicate Inv6.inv = Inv11.inv
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve3 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone Core_Ptr_ConstPtr_Impl0_IsNull_Interface as IsNull0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    predicate Inv0.inv = Inv4.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Ghost.ghost_ty (borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t))
  let rec cfg append [#"../src/lib.rs" 396 8 396 49] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)) (other : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) : ()
    requires {[#"../src/lib.rs" 392 19 392 38] Invariant0.invariant' ( * self)}
    requires {[#"../src/lib.rs" 393 19 393 36] Invariant0.invariant' other}
    requires {[#"../src/lib.rs" 396 27 396 31] Inv3.inv self}
    requires {[#"../src/lib.rs" 396 37 396 42] Inv2.inv other}
    ensures { [#"../src/lib.rs" 394 18 394 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"../src/lib.rs" 395 18 395 79] Seq.(==) (Model0.model ( ^ self)) (Seq.(++) (Model0.model ( * self)) (Model0.model other)) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) = self;
  var other : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t = other;
  var old_self : Ghost.ghost_ty (borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t));
  var old_other : Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
  var _11 : bool;
  var _15 : bool;
  var tail : borrowed (CargoDir_LinkedList_Node_Type.t_node t);
  var _18 : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
  var head : borrowed (CargoDir_LinkedList_Node_Type.t_node t);
  var _22 : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
  var _25 : ();
  var _26 : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
  var _29 : Ghost.ghost_ty (Seq.seq opaque_ptr);
  {
    goto BB0
  }
  BB0 {
    old_self <- ([#"../src/lib.rs" 397 27 397 36] Ghost.new self);
    goto BB1
  }
  BB1 {
    assert { [@expl:type invariant] Inv0.inv old_self };
    assume { Resolve0.resolve old_self };
    old_other <- ([#"../src/lib.rs" 398 28 398 38] Ghost.new other);
    goto BB2
  }
  BB2 {
    assert { [@expl:type invariant] Inv1.inv old_other };
    assume { Resolve1.resolve old_other };
    _11 <- ([#"../src/lib.rs" 399 15 399 34] IsNull0.is_null (CargoDir_LinkedList_LinkedList_Type.linkedlist_head ( * self)));
    goto BB3
  }
  BB3 {
    switch (_11)
      | False -> goto BB5
      | True -> goto BB4
      end
  }
  BB4 {
    self <- { self with current = other };
    other <- any CargoDir_LinkedList_LinkedList_Type.t_linkedlist t;
    assert { [@expl:type invariant] Inv2.inv ( * self) };
    assume { Resolve2.resolve ( * self) };
    assert { [@expl:type invariant] Inv3.inv self };
    assume { Resolve3.resolve self };
    _0 <- ();
    goto BB14
  }
  BB5 {
    _15 <- ([#"../src/lib.rs" 401 23 401 43] IsNull0.is_null (CargoDir_LinkedList_LinkedList_Type.linkedlist_head other));
    goto BB6
  }
  BB6 {
    switch (not _15)
      | False -> goto BB12
      | True -> goto BB7
      end
  }
  BB7 {
    _18 <- Borrow.borrow_mut (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self));
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c ( ^ _18)) };
    assume { Inv4.inv ( ^ _18) };
    tail <- ([#"../src/lib.rs" 402 27 402 59] PtrAsMut0.ptr_as_mut _18 (CargoDir_LinkedList_LinkedList_Type.linkedlist_tail ( * self)));
    _18 <- any borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
    goto BB8
  }
  BB8 {
    tail <- { tail with current = (let CargoDir_LinkedList_Node_Type.C_Node a b c =  * tail in CargoDir_LinkedList_Node_Type.C_Node a (CargoDir_LinkedList_LinkedList_Type.linkedlist_head other) c) };
    assume { Resolve4.resolve (CargoDir_LinkedList_Node_Type.node_next ( * tail)) };
    assert { [@expl:type invariant] Inv5.inv tail };
    assume { Resolve5.resolve tail };
    _22 <- Borrow.borrow_mut (CargoDir_LinkedList_LinkedList_Type.linkedlist_token other);
    other <- (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d = other in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c ( ^ _22));
    assume { Inv4.inv ( ^ _22) };
    head <- ([#"../src/lib.rs" 404 27 404 61] PtrAsMut0.ptr_as_mut _22 (CargoDir_LinkedList_LinkedList_Type.linkedlist_head other));
    _22 <- any borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
    goto BB9
  }
  BB9 {
    head <- { head with current = (let CargoDir_LinkedList_Node_Type.C_Node a b c =  * head in CargoDir_LinkedList_Node_Type.C_Node a b (CargoDir_LinkedList_LinkedList_Type.linkedlist_tail ( * self))) };
    assume { Resolve4.resolve (CargoDir_LinkedList_Node_Type.node_prev ( * head)) };
    assert { [@expl:type invariant] Inv5.inv head };
    assume { Resolve5.resolve head };
    _26 <- Borrow.borrow_mut (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self));
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c ( ^ _26)) };
    assume { Inv4.inv ( ^ _26) };
    _25 <- ([#"../src/lib.rs" 407 16 407 45] Merge0.merge _26 (CargoDir_LinkedList_LinkedList_Type.linkedlist_token other));
    _26 <- any borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
    other <- (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d = other in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c (any CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)));
    goto BB10
  }
  BB10 {
    assert { [@expl:type invariant] Inv2.inv other };
    assume { Resolve2.resolve other };
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a (CargoDir_LinkedList_LinkedList_Type.linkedlist_tail other) c d) };
    _29 <- ([#"../src/lib.rs" 409 28 409 62] Ghost.new (Seq.(++) (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs other))));
    goto BB11
  }
  BB11 {
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b _29 d) };
    _29 <- any Ghost.ghost_ty (Seq.seq opaque_ptr);
    assume { Resolve6.resolve (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) };
    assert { [@expl:type invariant] Inv3.inv self };
    assume { Resolve3.resolve self };
    assert { [@expl:assertion] [#"../src/lib.rs" 410 16 410 116] forall b : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t) . forall a : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t) . Inv6.inv b -> Inv6.inv a -> Disjoint0.disjoint a b -> Subset0.subset a (Union0.union a b) };
    assert { [@expl:assertion] [#"../src/lib.rs" 412 16 414 72] forall i : int . 0 <= i /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * Ghost.inner old_self))) - 1 -> Lookup0.lookup (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * Ghost.inner old_self))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * Ghost.inner old_self)) i) = Lookup0.lookup (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * Ghost.inner old_self)) i) };
    assert { [@expl:assertion] [#"../src/lib.rs" 415 16 417 73] forall i : int . 1 <= i /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs (Ghost.inner old_other))) -> Lookup0.lookup (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token (Ghost.inner old_other))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs (Ghost.inner old_other)) i) = Lookup0.lookup (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs (Ghost.inner old_other)) i) };
    assert { [@expl:assertion] [#"../src/lib.rs" 418 30 419 102] CargoDir_LinkedList_Node_Type.node_prev (Lookup0.lookup (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * Ghost.inner old_self)) (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * Ghost.inner old_self))) - 1))) = CargoDir_LinkedList_Node_Type.node_prev (Lookup0.lookup (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * Ghost.inner old_self))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * Ghost.inner old_self)) (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * Ghost.inner old_self))) - 1))) };
    assert { [@expl:assertion] [#"../src/lib.rs" 420 30 421 82] CargoDir_LinkedList_Node_Type.node_next (Lookup0.lookup (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs (Ghost.inner old_other)) 0)) = CargoDir_LinkedList_Node_Type.node_next (Lookup0.lookup (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token (Ghost.inner old_other))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs (Ghost.inner old_other)) 0)) };
    assert { [@expl:assertion] [#"../src/lib.rs" 422 30 422 68] WfToken0.wf_token ( * self) (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * Ghost.inner old_self))) - 1) };
    assert { [@expl:assertion] [#"../src/lib.rs" 423 30 423 64] WfToken0.wf_token ( * self) (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * Ghost.inner old_self)))) };
    assert { [@expl:assertion] [#"../src/lib.rs" 425 16 425 131] forall i : int . 0 <= i /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * Ghost.inner old_self))) - 1 -> WfToken0.wf_token ( * Ghost.inner old_self) i -> WfToken0.wf_token ( * self) i };
    assert { [@expl:assertion] [#"../src/lib.rs" 426 16 426 151] forall i : int . 1 <= i /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs (Ghost.inner old_other))) -> WfToken0.wf_token (Ghost.inner old_other) i -> WfToken0.wf_token ( * self) (i + Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * Ghost.inner old_self)))) };
    _0 <- ();
    goto BB13
  }
  BB12 {
    assert { [@expl:type invariant] Inv2.inv other };
    assume { Resolve2.resolve other };
    assert { [@expl:type invariant] Inv3.inv self };
    assume { Resolve3.resolve self };
    _0 <- ();
    goto BB13
  }
  BB13 {
    goto BB14
  }
  BB14 {
    return _0
  }
  
end
module CargoDir_LinkedList_Impl0_PushBack_Interface
  type t
  use prelude.Borrow
  use seq.Seq
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_Model_Stub as Model0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone CargoDir_LinkedList_Impl0_Invariant_Stub as Invariant0 with
    type t = t
  val push_back [#"../src/lib.rs" 433 8 433 43] (self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)) (val' : t) : ()
    requires {[#"../src/lib.rs" 430 19 430 38] Invariant0.invariant' ( * self)}
    requires {[#"../src/lib.rs" 433 30 433 34] Inv0.inv self}
    requires {[#"../src/lib.rs" 433 36 433 39] Inv1.inv val'}
    ensures { [#"../src/lib.rs" 431 18 431 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"../src/lib.rs" 432 18 432 85] Seq.(==) (Model0.model ( ^ self)) (Seq.(++) (Model0.model ( * self)) (Seq.singleton val')) }
    
end
module CargoDir_LinkedList_Impl0_PushBack
  type t
  use prelude.Borrow
  use seq.Seq
  use map.Map
  use prelude.Opaque
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Util_Unwrap_Interface as Unwrap0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv4.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv4.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv5.inv
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized as LookupUnsized0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get,
    function Unwrap0.unwrap = Unwrap0.unwrap,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv7.inv
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_NextOf as NextOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_PrevOf as PrevOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = t
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = t,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CargoDir_LinkedList_Impl0_WfToken as WfToken0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Contains0.contains = Contains0.contains,
    function Lookup0.lookup = Lookup0.lookup,
    function PrevOf0.prev_of = PrevOf0.prev_of,
    function NextOf0.next_of = NextOf0.next_of,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CargoDir_LinkedList_Impl0_Model as Model0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Lookup0.lookup = Lookup0.lookup
  clone CargoDir_LinkedList_Impl0_Invariant as Invariant0 with
    type t = t,
    predicate WfToken0.wf_token = WfToken0.wf_token,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone CargoDir_LinkedList_Impl0_Append_Interface as Append0 with
    type t = t,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv0.inv,
    function Model0.model = Model0.model
  clone CargoDir_LinkedList_Impl0_Singleton_Interface as Singleton0 with
    type t = t,
    predicate Inv0.inv = Inv2.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    function Model0.model = Model0.model,
    predicate Inv1.inv = Inv0.inv
  let rec cfg push_back [#"../src/lib.rs" 433 8 433 43] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)) (val' : t) : ()
    requires {[#"../src/lib.rs" 430 19 430 38] Invariant0.invariant' ( * self)}
    requires {[#"../src/lib.rs" 433 30 433 34] Inv1.inv self}
    requires {[#"../src/lib.rs" 433 36 433 39] Inv2.inv val'}
    ensures { [#"../src/lib.rs" 431 18 431 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"../src/lib.rs" 432 18 432 85] Seq.(==) (Model0.model ( ^ self)) (Seq.(++) (Model0.model ( * self)) (Seq.singleton val')) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) = self;
  var val' : t = val';
  var _6 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
  var _7 : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t;
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    _6 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _6) };
    assume { Inv0.inv ( ^ _6) };
    _7 <- ([#"../src/lib.rs" 434 24 434 44] Singleton0.singleton val');
    val' <- any t;
    goto BB2
  }
  BB2 {
    _0 <- ([#"../src/lib.rs" 434 12 434 45] Append0.append _6 _7);
    _6 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
    _7 <- any CargoDir_LinkedList_LinkedList_Type.t_linkedlist t;
    goto BB3
  }
  BB3 {
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve0.resolve self };
    goto BB4
  }
  BB4 {
    return _0
  }
  
end
module Core_Mem_Swap_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed t
  val swap (x : borrowed t) (y : borrowed t) : ()
    requires {Inv0.inv x}
    requires {Inv0.inv y}
    ensures { [#"../../../../creusot/creusot-contracts/src/std/mem.rs" 11 22 11 30]  ^ x =  * y }
    ensures { [#"../../../../creusot/creusot-contracts/src/std/mem.rs" 12 22 12 30]  ^ y =  * x }
    
end
module CargoDir_LinkedList_Impl0_PushFront_Interface
  type t
  use prelude.Borrow
  use seq.Seq
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_Model_Stub as Model0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone CargoDir_LinkedList_Impl0_Invariant_Stub as Invariant0 with
    type t = t
  val push_front [#"../src/lib.rs" 440 8 440 44] (self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)) (val' : t) : ()
    requires {[#"../src/lib.rs" 437 19 437 38] Invariant0.invariant' ( * self)}
    requires {[#"../src/lib.rs" 440 31 440 35] Inv0.inv self}
    requires {[#"../src/lib.rs" 440 37 440 40] Inv1.inv val'}
    ensures { [#"../src/lib.rs" 438 18 438 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"../src/lib.rs" 439 18 439 85] Seq.(==) (Model0.model ( ^ self)) (Seq.(++) (Seq.singleton val') (Model0.model ( * self))) }
    
end
module CargoDir_LinkedList_Impl0_PushFront
  type t
  use prelude.Borrow
  use seq.Seq
  use map.Map
  use prelude.Opaque
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Util_Unwrap_Interface as Unwrap0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv4.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv4.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv5.inv
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized as LookupUnsized0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get,
    function Unwrap0.unwrap = Unwrap0.unwrap,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv7.inv
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_NextOf as NextOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_PrevOf as PrevOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = t
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = t,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CargoDir_LinkedList_Impl0_WfToken as WfToken0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Contains0.contains = Contains0.contains,
    function Lookup0.lookup = Lookup0.lookup,
    function PrevOf0.prev_of = PrevOf0.prev_of,
    function NextOf0.next_of = NextOf0.next_of,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CargoDir_LinkedList_Impl0_Model as Model0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Lookup0.lookup = Lookup0.lookup
  clone CargoDir_LinkedList_Impl0_Invariant as Invariant0 with
    type t = t,
    predicate WfToken0.wf_token = WfToken0.wf_token,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CargoDir_LinkedList_Impl0_Append_Interface as Append0 with
    type t = t,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv0.inv,
    function Model0.model = Model0.model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone Core_Mem_Swap_Interface as Swap0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t,
    predicate Inv0.inv = Inv1.inv
  clone CargoDir_LinkedList_Impl0_Singleton_Interface as Singleton0 with
    type t = t,
    predicate Inv0.inv = Inv2.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    function Model0.model = Model0.model,
    predicate Inv1.inv = Inv0.inv
  let rec cfg push_front [#"../src/lib.rs" 440 8 440 44] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)) (val' : t) : ()
    requires {[#"../src/lib.rs" 437 19 437 38] Invariant0.invariant' ( * self)}
    requires {[#"../src/lib.rs" 440 31 440 35] Inv1.inv self}
    requires {[#"../src/lib.rs" 440 37 440 40] Inv2.inv val'}
    ensures { [#"../src/lib.rs" 438 18 438 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"../src/lib.rs" 439 18 439 85] Seq.(==) (Model0.model ( ^ self)) (Seq.(++) (Seq.singleton val') (Model0.model ( * self))) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) = self;
  var val' : t = val';
  var this : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t;
  var _8 : ();
  var _9 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
  var _10 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
  var _11 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
  var _12 : ();
  var _13 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    this <- ([#"../src/lib.rs" 441 27 441 47] Singleton0.singleton val');
    val' <- any t;
    goto BB2
  }
  BB2 {
    _9 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _9) };
    assume { Inv0.inv ( ^ _9) };
    _11 <- Borrow.borrow_mut this;
    this <-  ^ _11;
    assume { Inv0.inv ( ^ _11) };
    _10 <- Borrow.borrow_mut ( * _11);
    _11 <- { _11 with current = ( ^ _10) };
    assume { Inv0.inv ( ^ _10) };
    _8 <- ([#"../src/lib.rs" 442 12 442 43] Swap0.swap _9 _10);
    _9 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
    _10 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
    goto BB3
  }
  BB3 {
    assert { [@expl:type invariant] Inv1.inv _11 };
    assume { Resolve0.resolve _11 };
    _13 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _13) };
    assume { Inv0.inv ( ^ _13) };
    _12 <- ([#"../src/lib.rs" 443 12 443 29] Append0.append _13 this);
    _13 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
    this <- any CargoDir_LinkedList_LinkedList_Type.t_linkedlist t;
    goto BB4
  }
  BB4 {
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve0.resolve self };
    _0 <- ();
    goto BB5
  }
  BB5 {
    return _0
  }
  
end
module CargoDir_LinkedList_Iter_Type
  use prelude.Borrow
  use prelude.Opaque
  use prelude.Ghost
  use prelude.Int
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  type t_iter 't =
    | C_Iter (CargoDir_LinkedList_LinkedList_Type.t_linkedlist 't) opaque_ptr (Ghost.ghost_ty int)
    
  let function iter_curr (self : t_iter 't) : opaque_ptr = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Iter _ a _ -> a
      end
  let function iter_l (self : t_iter 't) : CargoDir_LinkedList_LinkedList_Type.t_linkedlist 't
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Iter a _ _ -> a
      end
  let function iter_index (self : t_iter 't) : Ghost.ghost_ty int = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Iter _ _ a -> a
      end
end
module CargoDir_LinkedList_Impl1_Invariant_Stub
  type t
  use CargoDir_LinkedList_Iter_Type as CargoDir_LinkedList_Iter_Type
  predicate invariant' [#"../src/lib.rs" 469 8 469 38] (self : CargoDir_LinkedList_Iter_Type.t_iter t)
end
module CargoDir_LinkedList_Impl1_Invariant_Interface
  type t
  use CargoDir_LinkedList_Iter_Type as CargoDir_LinkedList_Iter_Type
  predicate invariant' [#"../src/lib.rs" 469 8 469 38] (self : CargoDir_LinkedList_Iter_Type.t_iter t)
  val invariant' [#"../src/lib.rs" 469 8 469 38] (self : CargoDir_LinkedList_Iter_Type.t_iter t) : bool
    ensures { result = invariant' self }
    
end
module CargoDir_LinkedList_Impl1_Invariant
  type t
  use prelude.Ghost
  use seq.Seq
  use prelude.Int
  use prelude.Opaque
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Stub as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic_Stub as IndexLogic0 with
    type t = opaque_ptr
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_Model_Stub as Model0 with
    type t = t
  clone CargoDir_LinkedList_Impl0_Invariant_Stub as Invariant0 with
    type t = t
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Stub as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_Iter_Type as CargoDir_LinkedList_Iter_Type
  predicate invariant' [#"../src/lib.rs" 469 8 469 38] (self : CargoDir_LinkedList_Iter_Type.t_iter t) =
    [#"../src/lib.rs" 470 12 480 13] if CargoDir_LinkedList_Iter_Type.iter_curr self <> NullLogic0.null_logic () then
      Invariant0.invariant' (CargoDir_LinkedList_Iter_Type.iter_l self) /\ Ghost.inner (CargoDir_LinkedList_Iter_Type.iter_index self) < Seq.length (Model0.model (CargoDir_LinkedList_Iter_Type.iter_l self)) /\ CargoDir_LinkedList_Iter_Type.iter_curr self = IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs (CargoDir_LinkedList_Iter_Type.iter_l self)) (Ghost.inner (CargoDir_LinkedList_Iter_Type.iter_index self)) /\ Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs (CargoDir_LinkedList_Iter_Type.iter_l self))) > 0 /\ Ghost.inner (CargoDir_LinkedList_Iter_Type.iter_index self) >= 0
    else
      true
    
  val invariant' [#"../src/lib.rs" 469 8 469 38] (self : CargoDir_LinkedList_Iter_Type.t_iter t) : bool
    ensures { result = invariant' self }
    
end
module CargoDir_LinkedList_Impl0_Iter_Interface
  type t
  use prelude.Ghost
  use seq.Seq
  use prelude.Int
  use prelude.Borrow
  use CargoDir_LinkedList_Iter_Type as CargoDir_LinkedList_Iter_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = CargoDir_LinkedList_Iter_Type.t_iter t
  clone CargoDir_LinkedList_Impl1_Invariant_Stub as Invariant1 with
    type t = t
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone CargoDir_LinkedList_Impl0_Invariant_Stub as Invariant0 with
    type t = t
  val iter [#"../src/lib.rs" 451 8 451 41] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) : CargoDir_LinkedList_Iter_Type.t_iter t
    requires {[#"../src/lib.rs" 446 19 446 38] Invariant0.invariant' self}
    requires {[#"../src/lib.rs" 447 19 447 38] Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self)) > 0}
    requires {[#"../src/lib.rs" 451 21 451 25] Inv0.inv self}
    ensures { [#"../src/lib.rs" 448 18 448 36] Invariant1.invariant' result }
    ensures { [#"../src/lib.rs" 451 30 451 41] Inv1.inv result }
    
end
module CargoDir_LinkedList_Impl0_Iter
  type t
  use prelude.Ghost
  use prelude.Int
  use prelude.Borrow
  use seq.Seq
  use map.Map
  use prelude.Opaque
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Util_Unwrap_Interface as Unwrap0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv4.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv4.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv5.inv
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized as LookupUnsized0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get,
    function Unwrap0.unwrap = Unwrap0.unwrap,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv7.inv
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_NextOf as NextOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_PrevOf as PrevOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized
  use CargoDir_LinkedList_Iter_Type as CargoDir_LinkedList_Iter_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = CargoDir_LinkedList_Iter_Type.t_iter t
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = CargoDir_LinkedList_Iter_Type.t_iter t,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CargoDir_LinkedList_Impl0_Model as Model0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Lookup0.lookup = Lookup0.lookup
  clone CargoDir_LinkedList_Impl0_WfToken as WfToken0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Contains0.contains = Contains0.contains,
    function Lookup0.lookup = Lookup0.lookup,
    function PrevOf0.prev_of = PrevOf0.prev_of,
    function NextOf0.next_of = NextOf0.next_of,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CargoDir_LinkedList_Impl0_Invariant as Invariant0 with
    type t = t,
    predicate WfToken0.wf_token = WfToken0.wf_token,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CargoDir_LinkedList_Impl1_Invariant as Invariant1 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    predicate Invariant0.invariant' = Invariant0.invariant',
    function Model0.model = Model0.model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  let rec cfg iter [#"../src/lib.rs" 451 8 451 41] [@cfg:stackify] [@cfg:subregion_analysis] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) : CargoDir_LinkedList_Iter_Type.t_iter t
    requires {[#"../src/lib.rs" 446 19 446 38] Invariant0.invariant' self}
    requires {[#"../src/lib.rs" 447 19 447 38] Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self)) > 0}
    requires {[#"../src/lib.rs" 451 21 451 25] Inv1.inv self}
    ensures { [#"../src/lib.rs" 448 18 448 36] Invariant1.invariant' result }
    ensures { [#"../src/lib.rs" 451 30 451 41] Inv2.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : CargoDir_LinkedList_Iter_Type.t_iter t;
  var self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t = self;
  var _6 : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t;
  var _8 : Ghost.ghost_ty int;
  {
    goto BB0
  }
  BB0 {
    _6 <- self;
    assert { [@expl:type invariant] Inv0.inv _6 };
    assume { Resolve0.resolve _6 };
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve1.resolve self };
    _8 <- ([#"../src/lib.rs" 455 23 455 29] Ghost.new 0);
    goto BB1
  }
  BB1 {
    _0 <- CargoDir_LinkedList_Iter_Type.C_Iter _6 (CargoDir_LinkedList_LinkedList_Type.linkedlist_head self) _8;
    _8 <- any Ghost.ghost_ty int;
    return _0
  }
  
end
module CreusotContracts_Model_Impl5_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl5_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl5_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy =
    [#"../../../../creusot/creusot-contracts/src/model.rs" 83 8 83 31] ShallowModel0.shallow_model self
  val shallow_model (self : t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_GhostPtr_Impl1_PtrAsRef_Interface
  type t
  use prelude.Borrow
  use prelude.Opaque
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized_Stub as LookupUnsized0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t,
    type ShallowModelTy0.shallowModelTy = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
  val ptr_as_ref (self : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t) (ptr : opaque_ptr) : t
    requires {[#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 65 4 65 36] Contains0.contains (ShallowModel0.shallow_model self) ptr}
    requires {[#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 67 23 67 27] Inv0.inv self}
    ensures { [#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 66 14 66 51] result = LookupUnsized0.lookup_unsized (ShallowModel0.shallow_model self) ptr }
    ensures { [#"../../../../creusot/creusot-contracts/src/ghost_ptr.rs" 67 4 67 49] Inv1.inv result }
    
end
module CargoDir_LinkedList_Impl1_Next_Interface
  type t
  use prelude.Borrow
  use prelude.Ghost
  use seq.Seq
  use prelude.Int
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Core_Option_Option_Type.t_option t
  clone CargoDir_LinkedList_Impl0_Model_Stub as Model0 with
    type t = t
  use CargoDir_LinkedList_Iter_Type as CargoDir_LinkedList_Iter_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (CargoDir_LinkedList_Iter_Type.t_iter t)
  clone CargoDir_LinkedList_Impl1_Invariant_Stub as Invariant0 with
    type t = t
  val next [#"../src/lib.rs" 505 8 505 47] (self : borrowed (CargoDir_LinkedList_Iter_Type.t_iter t)) : Core_Option_Option_Type.t_option t
    requires {[#"../src/lib.rs" 495 19 495 38] Invariant0.invariant' ( * self)}
    requires {[#"../src/lib.rs" 505 25 505 29] Inv0.inv self}
    ensures { [#"../src/lib.rs" 496 18 496 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"../src/lib.rs" 497 18 500 9] match (result) with
      | Core_Option_Option_Type.C_Some val' -> val' = Seq.get (Model0.model (CargoDir_LinkedList_Iter_Type.iter_l ( * self))) (Ghost.inner (CargoDir_LinkedList_Iter_Type.iter_index ( * self)))
      | Core_Option_Option_Type.C_None -> true
      end }
    ensures { [#"../src/lib.rs" 501 18 504 9] match (result) with
      | Core_Option_Option_Type.C_Some val' -> Ghost.inner (CargoDir_LinkedList_Iter_Type.iter_index ( ^ self)) = Ghost.inner (CargoDir_LinkedList_Iter_Type.iter_index ( * self)) + 1
      | Core_Option_Option_Type.C_None -> true
      end }
    ensures { [#"../src/lib.rs" 505 34 505 47] Inv1.inv result }
    
end
module CargoDir_LinkedList_Impl1_Next
  type t
  use prelude.Borrow
  use prelude.Ghost
  use prelude.Int
  use seq.Seq
  use map.Map
  use prelude.Opaque
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial12 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv12.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial11 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial10 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv11.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Util_Unwrap_Interface as Unwrap0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv10.inv,
    axiom .
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv11.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv12.inv
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = opaque_ptr
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = opaque_ptr,
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Core_Option_Option_Type.t_option t
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = Core_Option_Option_Type.t_option t,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv7.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_NextOf as NextOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv7.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_PrevOf as PrevOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv7.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized as LookupUnsized0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get,
    function Unwrap0.unwrap = Unwrap0.unwrap,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv10.inv
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized
  clone CargoDir_LinkedList_Impl0_WfToken as WfToken0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Contains0.contains = Contains0.contains,
    function Lookup0.lookup = Lookup0.lookup,
    function PrevOf0.prev_of = PrevOf0.prev_of,
    function NextOf0.next_of = NextOf0.next_of,
    axiom .
  clone CargoDir_LinkedList_Impl0_Invariant as Invariant1 with
    type t = t,
    predicate WfToken0.wf_token = WfToken0.wf_token,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv7.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = t
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = t,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  use CargoDir_LinkedList_Iter_Type as CargoDir_LinkedList_Iter_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = borrowed (CargoDir_LinkedList_Iter_Type.t_iter t)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = borrowed (CargoDir_LinkedList_Iter_Type.t_iter t),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    type ShallowModelTy0.shallowModelTy = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CargoDir_LinkedList_Impl0_Model as Model0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Lookup0.lookup = Lookup0.lookup
  clone CargoDir_LinkedList_Impl1_Invariant as Invariant0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    predicate Invariant0.invariant' = Invariant1.invariant',
    function Model0.model = Model0.model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv7.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = CargoDir_LinkedList_Iter_Type.t_iter t
  clone CreusotContracts_GhostPtr_Impl1_PtrAsRef_Interface as PtrAsRef0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function Contains0.contains = Contains0.contains,
    predicate Inv0.inv = Inv8.inv,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized,
    predicate Inv1.inv = Inv1.inv
  clone Core_Ptr_ConstPtr_Impl0_IsNull_Interface as IsNull0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    predicate Inv0.inv = Inv7.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = ()
  clone CargoDir_Lemmas_MapSetCommute_Interface as MapSetCommute0 with
    type k = opaque_ptr,
    type v = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv5.inv,
    predicate Inv2.inv = Inv6.inv,
    axiom .
  let rec cfg next [#"../src/lib.rs" 505 8 505 47] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (CargoDir_LinkedList_Iter_Type.t_iter t)) : Core_Option_Option_Type.t_option t
    requires {[#"../src/lib.rs" 495 19 495 38] Invariant0.invariant' ( * self)}
    requires {[#"../src/lib.rs" 505 25 505 29] Inv0.inv self}
    ensures { [#"../src/lib.rs" 496 18 496 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"../src/lib.rs" 497 18 500 9] match (result) with
      | Core_Option_Option_Type.C_Some val' -> val' = Seq.get (Model0.model (CargoDir_LinkedList_Iter_Type.iter_l ( * self))) (Ghost.inner (CargoDir_LinkedList_Iter_Type.iter_index ( * self)))
      | Core_Option_Option_Type.C_None -> true
      end }
    ensures { [#"../src/lib.rs" 501 18 504 9] match (result) with
      | Core_Option_Option_Type.C_Some val' -> Ghost.inner (CargoDir_LinkedList_Iter_Type.iter_index ( ^ self)) = Ghost.inner (CargoDir_LinkedList_Iter_Type.iter_index ( * self)) + 1
      | Core_Option_Option_Type.C_None -> true
      end }
    ensures { [#"../src/lib.rs" 505 34 505 47] Inv3.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option t;
  var self : borrowed (CargoDir_LinkedList_Iter_Type.t_iter t) = self;
  var _6 : ();
  var _8 : bool;
  var node : CargoDir_LinkedList_Node_Type.t_node t;
  var _17 : Ghost.ghost_ty int;
  var _20 : t;
  {
    goto BB0
  }
  BB0 {
    _6 <- ([#"../src/lib.rs" 506 12 506 62] ());
    assume { Resolve0.resolve _6 };
    _8 <- ([#"../src/lib.rs" 507 15 507 34] IsNull0.is_null (CargoDir_LinkedList_Iter_Type.iter_curr ( * self)));
    goto BB1
  }
  BB1 {
    switch (_8)
      | False -> goto BB3
      | True -> goto BB2
      end
  }
  BB2 {
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve1.resolve self };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB6
  }
  BB3 {
    assert { [@expl:assertion] [#"../src/lib.rs" 511 12 511 55] WfToken0.wf_token (CargoDir_LinkedList_Iter_Type.iter_l ( * self)) (Ghost.inner (CargoDir_LinkedList_Iter_Type.iter_index ( * self))) };
    node <- ([#"../src/lib.rs" 512 23 512 57] PtrAsRef0.ptr_as_ref (CargoDir_LinkedList_LinkedList_Type.linkedlist_token (CargoDir_LinkedList_Iter_Type.iter_l ( * self))) (CargoDir_LinkedList_Iter_Type.iter_curr ( * self)));
    goto BB4
  }
  BB4 {
    self <- { self with current = (let CargoDir_LinkedList_Iter_Type.C_Iter a b c =  * self in CargoDir_LinkedList_Iter_Type.C_Iter a (CargoDir_LinkedList_Node_Type.node_next node) c) };
    _17 <- ([#"../src/lib.rs" 514 25 514 45] Ghost.new (Ghost.inner (CargoDir_LinkedList_Iter_Type.iter_index ( * self)) + 1));
    goto BB5
  }
  BB5 {
    self <- { self with current = (let CargoDir_LinkedList_Iter_Type.C_Iter a b c =  * self in CargoDir_LinkedList_Iter_Type.C_Iter a b _17) };
    _17 <- any Ghost.ghost_ty int;
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve1.resolve self };
    _20 <- CargoDir_LinkedList_Node_Type.node_data node;
    assert { [@expl:type invariant] Inv1.inv node };
    assume { Resolve2.resolve node };
    assert { [@expl:type invariant] Inv2.inv _20 };
    assume { Resolve3.resolve _20 };
    _0 <- Core_Option_Option_Type.C_Some _20;
    goto BB6
  }
  BB6 {
    return _0
  }
  
end
module CargoDir_Main_Main_Interface
  val main [#"../src/lib.rs" 524 4 524 13] (_1 : ()) : ()
end
module CargoDir_Main_Main
  use prelude.Int
  use prelude.Int32
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = int32
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = int32,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CargoDir_LinkedList_Impl0_Model_Interface as Model0 with
    type t = int32
  clone CargoDir_LinkedList_Impl0_Invariant_Interface as Invariant0 with
    type t = int32
  clone CargoDir_LinkedList_Impl0_PushBack_Interface as PushBack0 with
    type t = int32,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv2.inv,
    function Model0.model = Model0.model
  clone CargoDir_LinkedList_Impl0_New_Interface as New0 with
    type t = int32,
    predicate Invariant0.invariant' = Invariant0.invariant',
    function Model0.model = Model0.model,
    predicate Inv0.inv = Inv0.inv
  let rec cfg main [#"../src/lib.rs" 524 4 524 13] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var l1 : CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32;
  var l2 : CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32;
  var l3 : CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32;
  var l4 : CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32;
  var _5 : ();
  var _6 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
  var _7 : ();
  var _8 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
  var _9 : ();
  var _10 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
  var _11 : ();
  var _12 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
  var _13 : ();
  var _14 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
  var _15 : ();
  var _16 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
  var _17 : ();
  var _18 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
  var _19 : ();
  var _20 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
  var _21 : ();
  var _22 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
  var _23 : ();
  var _24 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
  var _25 : ();
  var _26 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
  var _27 : ();
  var _28 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
  var _29 : ();
  var _30 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
  var _31 : ();
  var _32 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
  var _33 : ();
  var _34 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
  var _35 : ();
  var _36 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
  {
    goto BB0
  }
  BB0 {
    l1 <- ([#"../src/lib.rs" 525 21 525 38] New0.new ());
    goto BB1
  }
  BB1 {
    l2 <- ([#"../src/lib.rs" 526 21 526 38] New0.new ());
    goto BB2
  }
  BB2 {
    l3 <- ([#"../src/lib.rs" 527 21 527 38] New0.new ());
    goto BB3
  }
  BB3 {
    l4 <- ([#"../src/lib.rs" 528 21 528 38] New0.new ());
    goto BB4
  }
  BB4 {
    _6 <- Borrow.borrow_mut l1;
    l1 <-  ^ _6;
    _5 <- ([#"../src/lib.rs" 530 4 530 19] PushBack0.push_back _6 ([#"../src/lib.rs" 530 17 530 18] (0 : int32)));
    _6 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
    goto BB5
  }
  BB5 {
    _8 <- Borrow.borrow_mut l2;
    l2 <-  ^ _8;
    _7 <- ([#"../src/lib.rs" 531 4 531 19] PushBack0.push_back _8 ([#"../src/lib.rs" 531 17 531 18] (0 : int32)));
    _8 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
    goto BB6
  }
  BB6 {
    _10 <- Borrow.borrow_mut l3;
    l3 <-  ^ _10;
    _9 <- ([#"../src/lib.rs" 532 4 532 19] PushBack0.push_back _10 ([#"../src/lib.rs" 532 17 532 18] (0 : int32)));
    _10 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
    goto BB7
  }
  BB7 {
    _12 <- Borrow.borrow_mut l4;
    l4 <-  ^ _12;
    _11 <- ([#"../src/lib.rs" 533 4 533 19] PushBack0.push_back _12 ([#"../src/lib.rs" 533 17 533 18] (0 : int32)));
    _12 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
    goto BB8
  }
  BB8 {
    _14 <- Borrow.borrow_mut l1;
    l1 <-  ^ _14;
    _13 <- ([#"../src/lib.rs" 535 4 535 19] PushBack0.push_back _14 ([#"../src/lib.rs" 535 17 535 18] (1 : int32)));
    _14 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
    goto BB9
  }
  BB9 {
    _16 <- Borrow.borrow_mut l2;
    l2 <-  ^ _16;
    _15 <- ([#"../src/lib.rs" 536 4 536 19] PushBack0.push_back _16 ([#"../src/lib.rs" 536 17 536 18] (1 : int32)));
    _16 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
    goto BB10
  }
  BB10 {
    _18 <- Borrow.borrow_mut l3;
    l3 <-  ^ _18;
    _17 <- ([#"../src/lib.rs" 537 4 537 19] PushBack0.push_back _18 ([#"../src/lib.rs" 537 17 537 18] (1 : int32)));
    _18 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
    goto BB11
  }
  BB11 {
    _20 <- Borrow.borrow_mut l4;
    l4 <-  ^ _20;
    _19 <- ([#"../src/lib.rs" 538 4 538 19] PushBack0.push_back _20 ([#"../src/lib.rs" 538 17 538 18] (1 : int32)));
    _20 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
    goto BB12
  }
  BB12 {
    _22 <- Borrow.borrow_mut l1;
    l1 <-  ^ _22;
    _21 <- ([#"../src/lib.rs" 540 4 540 19] PushBack0.push_back _22 ([#"../src/lib.rs" 540 17 540 18] (2 : int32)));
    _22 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
    goto BB13
  }
  BB13 {
    _24 <- Borrow.borrow_mut l2;
    l2 <-  ^ _24;
    _23 <- ([#"../src/lib.rs" 541 4 541 19] PushBack0.push_back _24 ([#"../src/lib.rs" 541 17 541 18] (2 : int32)));
    _24 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
    goto BB14
  }
  BB14 {
    _26 <- Borrow.borrow_mut l3;
    l3 <-  ^ _26;
    _25 <- ([#"../src/lib.rs" 542 4 542 19] PushBack0.push_back _26 ([#"../src/lib.rs" 542 17 542 18] (2 : int32)));
    _26 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
    goto BB15
  }
  BB15 {
    _28 <- Borrow.borrow_mut l4;
    l4 <-  ^ _28;
    _27 <- ([#"../src/lib.rs" 543 4 543 19] PushBack0.push_back _28 ([#"../src/lib.rs" 543 17 543 18] (2 : int32)));
    _28 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
    goto BB16
  }
  BB16 {
    _30 <- Borrow.borrow_mut l1;
    l1 <-  ^ _30;
    _29 <- ([#"../src/lib.rs" 545 4 545 19] PushBack0.push_back _30 ([#"../src/lib.rs" 545 17 545 18] (3 : int32)));
    _30 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
    goto BB17
  }
  BB17 {
    _32 <- Borrow.borrow_mut l2;
    l2 <-  ^ _32;
    _31 <- ([#"../src/lib.rs" 546 4 546 19] PushBack0.push_back _32 ([#"../src/lib.rs" 546 17 546 18] (3 : int32)));
    _32 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
    goto BB18
  }
  BB18 {
    _34 <- Borrow.borrow_mut l3;
    l3 <-  ^ _34;
    _33 <- ([#"../src/lib.rs" 547 4 547 19] PushBack0.push_back _34 ([#"../src/lib.rs" 547 17 547 18] (3 : int32)));
    _34 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
    goto BB19
  }
  BB19 {
    _36 <- Borrow.borrow_mut l4;
    l4 <-  ^ _36;
    _35 <- ([#"../src/lib.rs" 548 4 548 19] PushBack0.push_back _36 ([#"../src/lib.rs" 548 17 548 18] (3 : int32)));
    _36 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist int32);
    goto BB20
  }
  BB20 {
    _0 <- ();
    return _0
  }
  
end
