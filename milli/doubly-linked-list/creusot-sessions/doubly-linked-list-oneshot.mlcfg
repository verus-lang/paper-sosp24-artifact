
module CreusotContracts_Invariant_Inv_Stub
  type t
  predicate inv (_x : t)
end
module CreusotContracts_Invariant_Inv_Interface
  type t
  predicate inv (_x : t)
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module CreusotContracts_Invariant_Inv
  type t
  predicate inv (_x : t) =
    [#"/root/creusot/creusot-contracts/src/invariant.rs" 16 4 16 8] true
  val inv (_x : t) : bool
    ensures { result = inv _x }
    
end
module TyInv_Trivial
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  axiom inv_trivial : forall self : t . Inv0.inv self = true
end
module CargoDir_Lemmas_MapSetCommute_Stub
  type k
  type v
  use map.Map
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Map.map k v
  function map_set_commute [#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 4 16 78] (x : Map.map k v) (k1 : k) (k2 : k) (v1 : v) (v2 : v) : ()
    
end
module CargoDir_Lemmas_MapSetCommute_Interface
  type k
  type v
  use map.Map
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Map.map k v
  function map_set_commute [#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 4 16 78] (x : Map.map k v) (k1 : k) (k2 : k) (v1 : v) (v2 : v) : ()
    
  val map_set_commute [#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 4 16 78] (x : Map.map k v) (k1 : k) (k2 : k) (v1 : v) (v2 : v) : ()
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 14 15 14 23] k1 <> k2}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 33 16 34] Inv0.inv x}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 51 16 53] Inv1.inv k1}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 58 16 60] Inv1.inv k2}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 65 16 67] Inv2.inv v1}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 72 16 74] Inv2.inv v2}
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 15 14 15 68] Map.set (Map.set x k1 v1) k2 v2 = Map.set (Map.set x k2 v2) k1 v1 }
    ensures { result = map_set_commute x k1 k2 v1 v2 }
    
  axiom map_set_commute_spec : forall x : Map.map k v, k1 : k, k2 : k, v1 : v, v2 : v . ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 14 15 14 23] k1 <> k2) -> ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 33 16 34] Inv0.inv x) -> ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 51 16 53] Inv1.inv k1) -> ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 58 16 60] Inv1.inv k2) -> ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 65 16 67] Inv2.inv v1) -> ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 72 16 74] Inv2.inv v2) -> ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 15 14 15 68] Map.set (Map.set x k1 v1) k2 v2 = Map.set (Map.set x k2 v2) k1 v1)
end
module CargoDir_Lemmas_MapSetCommute
  type k
  type v
  use map.Map
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Map.map k v
  function map_set_commute [#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 4 16 78] (x : Map.map k v) (k1 : k) (k2 : k) (v1 : v) (v2 : v) : ()
    
   =
    [#"/root/milli/creusot/cargo-dir/src/lib.rs" 12 4 12 10] ()
  val map_set_commute [#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 4 16 78] (x : Map.map k v) (k1 : k) (k2 : k) (v1 : v) (v2 : v) : ()
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 14 15 14 23] k1 <> k2}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 33 16 34] Inv0.inv x}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 51 16 53] Inv1.inv k1}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 58 16 60] Inv1.inv k2}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 65 16 67] Inv2.inv v1}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 72 16 74] Inv2.inv v2}
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 15 14 15 68] Map.set (Map.set x k1 v1) k2 v2 = Map.set (Map.set x k2 v2) k1 v1 }
    ensures { result = map_set_commute x k1 k2 v1 v2 }
    
  axiom map_set_commute_spec : forall x : Map.map k v, k1 : k, k2 : k, v1 : v, v2 : v . ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 14 15 14 23] k1 <> k2) -> ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 33 16 34] Inv0.inv x) -> ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 51 16 53] Inv1.inv k1) -> ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 58 16 60] Inv1.inv k2) -> ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 65 16 67] Inv2.inv v1) -> ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 72 16 74] Inv2.inv v2) -> ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 15 14 15 68] Map.set (Map.set x k1 v1) k2 v2 = Map.set (Map.set x k2 v2) k1 v1)
end
module CargoDir_Lemmas_MapSetCommute_Impl
  type k
  type v
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = v
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = v,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = k
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = k,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Map.map k v
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Map.map k v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  let rec ghost function map_set_commute [#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 4 16 78] (x : Map.map k v) (k1 : k) (k2 : k) (v1 : v) (v2 : v) : ()
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 14 15 14 23] k1 <> k2}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 33 16 34] Inv0.inv x}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 51 16 53] Inv1.inv k1}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 58 16 60] Inv1.inv k2}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 65 16 67] Inv2.inv v1}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 16 72 16 74] Inv2.inv v2}
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 15 14 15 68] Map.set (Map.set x k1 v1) k2 v2 = Map.set (Map.set x k2 v2) k1 v1 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/root/milli/creusot/cargo-dir/src/lib.rs" 12 4 12 10] ()
end
module CreusotContracts_GhostPtr_GhostPtrToken_Type
  type t_ghostptrtoken 't
end
module CargoDir_LinkedList_Node_Type
  use prelude.Opaque
  type t_node 't =
    | C_Node 't opaque_ptr opaque_ptr
    
  let function node_prev (self : t_node 't) : opaque_ptr = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Node _ _ a -> a
      end
  let function node_next (self : t_node 't) : opaque_ptr = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Node _ a _ -> a
      end
  let function node_data (self : t_node 't) : 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Node a _ _ -> a
      end
end
module CargoDir_LinkedList_LinkedList_Type
  use prelude.Opaque
  use prelude.Ghost
  use seq.Seq
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  type t_linkedlist 't =
    | C_LinkedList opaque_ptr opaque_ptr (Ghost.ghost_ty (Seq.seq opaque_ptr)) (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node 't))
    
  let function linkedlist_ptrs (self : t_linkedlist 't) : Ghost.ghost_ty (Seq.seq opaque_ptr)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_LinkedList _ _ a _ -> a
      end
  let function linkedlist_token (self : t_linkedlist 't) : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node 't)
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_LinkedList _ _ _ a -> a
      end
  let function linkedlist_head (self : t_linkedlist 't) : opaque_ptr = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_LinkedList a _ _ _ -> a
      end
  let function linkedlist_tail (self : t_linkedlist 't) : opaque_ptr = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_LinkedList _ a _ _ -> a
      end
end
module CreusotContracts_Logic_Fmap_FMap_Type
  type t_fmap 'k 'v
end
module CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub
  type t
  use prelude.Opaque
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  function shallow_model (self : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
    
end
module CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface
  type t
  use prelude.Opaque
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  function shallow_model (self : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
    
  val shallow_model (self : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
    ensures { result = shallow_model self }
    
end
module CreusotContracts_GhostPtr_Impl0_ShallowModel
  type t
  use prelude.Opaque
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  function shallow_model (self : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
    
  val shallow_model (self : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
    ensures { result = shallow_model self }
    
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
end
module CreusotContracts_Logic_Fmap_Impl0_Mk_Stub
  type k
  type v
  use map.Map
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  function mk (_m : Map.map k (Core_Option_Option_Type.t_option v)) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
end
module CreusotContracts_Logic_Fmap_Impl0_Mk_Interface
  type k
  type v
  use map.Map
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  function mk (_m : Map.map k (Core_Option_Option_Type.t_option v)) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  val mk (_m : Map.map k (Core_Option_Option_Type.t_option v)) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    ensures { result = mk _m }
    
end
module CreusotContracts_Logic_Fmap_Impl0_Mk
  type k
  type v
  use map.Map
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  function mk (_m : Map.map k (Core_Option_Option_Type.t_option v)) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  val mk (_m : Map.map k (Core_Option_Option_Type.t_option v)) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    ensures { result = mk _m }
    
end
module CreusotContracts_Logic_Fmap_Impl0_View_Stub
  type k
  type v
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  function view (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : Map.map k (Core_Option_Option_Type.t_option v)
    
end
module CreusotContracts_Logic_Fmap_Impl0_View_Interface
  type k
  type v
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  function view (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : Map.map k (Core_Option_Option_Type.t_option v)
    
  val view (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : Map.map k (Core_Option_Option_Type.t_option v)
    requires {[#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 28 16 28 20] Inv0.inv self}
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 27 14 27 38] Mk0.mk result = self }
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 28 4 28 35] Inv1.inv result }
    ensures { result = view self }
    
  axiom view_spec : forall self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v . ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 28 16 28 20] Inv0.inv self) -> ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 28 4 28 35] Inv1.inv (view self)) && ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 27 14 27 38] Mk0.mk (view self) = self)
end
module CreusotContracts_Logic_Fmap_Impl0_View
  type k
  type v
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  function view (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : Map.map k (Core_Option_Option_Type.t_option v)
    
  val view (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : Map.map k (Core_Option_Option_Type.t_option v)
    requires {[#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 28 16 28 20] Inv0.inv self}
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 27 14 27 38] Mk0.mk result = self }
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 28 4 28 35] Inv1.inv result }
    ensures { result = view self }
    
  axiom view_spec : forall self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v . ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 28 16 28 20] Inv0.inv self) -> ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 28 4 28 35] Inv1.inv (view self)) && ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 27 14 27 38] Mk0.mk (view self) = self)
end
module CreusotContracts_Logic_Fmap_Impl0_Get_Stub
  type k
  type v
  use Core_Option_Option_Type as Core_Option_Option_Type
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function get [@inline:trivial] (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : Core_Option_Option_Type.t_option v
    
end
module CreusotContracts_Logic_Fmap_Impl0_Get_Interface
  type k
  type v
  use Core_Option_Option_Type as Core_Option_Option_Type
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function get [@inline:trivial] (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : Core_Option_Option_Type.t_option v
    
  val get [@inline:trivial] (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : Core_Option_Option_Type.t_option v
    ensures { result = get self k }
    
end
module CreusotContracts_Logic_Fmap_Impl0_Get
  type k
  type v
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  function get [@inline:trivial] (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : Core_Option_Option_Type.t_option v
    
   =
    [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 55 8 55 26] Map.get (View0.view self) k
  val get [@inline:trivial] (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : Core_Option_Option_Type.t_option v
    ensures { result = get self k }
    
end
module CreusotContracts_Logic_Fmap_Impl0_Contains_Stub
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function contains (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : bool
end
module CreusotContracts_Logic_Fmap_Impl0_Contains_Interface
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function contains (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : bool
  val contains (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : bool
    ensures { result = contains self k }
    
end
module CreusotContracts_Logic_Fmap_Impl0_Contains
  type k
  type v
  use Core_Option_Option_Type as Core_Option_Option_Type
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Get_Stub as Get0 with
    type k = k,
    type v = v
  function contains (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : bool =
    [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 77 8 77 27] Get0.get self k <> Core_Option_Option_Type.C_None
  val contains (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : bool
    ensures { result = contains self k }
    
end
module CreusotContracts_GhostPtr_Impl2_AddrLogic_Stub
  type t
  use prelude.Opaque
  use prelude.Int
  function addr_logic (self : opaque_ptr) : int
end
module CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface
  type t
  use prelude.Opaque
  use prelude.Int
  function addr_logic (self : opaque_ptr) : int
  val addr_logic (self : opaque_ptr) : int
    ensures { result = addr_logic self }
    
end
module CreusotContracts_GhostPtr_Impl2_AddrLogic
  type t
  use prelude.Opaque
  use prelude.Int
  function addr_logic (self : opaque_ptr) : int
  val addr_logic (self : opaque_ptr) : int
    ensures { result = addr_logic self }
    
end
module CreusotContracts_GhostPtr_Impl2_NullLogic_Stub
  type t
  use prelude.Opaque
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Stub as AddrLogic0 with
    type t = t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = t
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t
  function null_logic (_1 : ()) : opaque_ptr
end
module CreusotContracts_GhostPtr_Impl2_NullLogic_Interface
  type t
  use prelude.Opaque
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Stub as AddrLogic0 with
    type t = t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = t
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t
  function null_logic (_1 : ()) : opaque_ptr
  val null_logic (_1 : ()) : opaque_ptr
    ensures { [#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 129 4 129 64] forall t : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t . Inv0.inv t -> not Contains0.contains (ShallowModel0.shallow_model t) result }
    ensures { [#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 131 4 131 98] forall ptr : opaque_ptr . AddrLogic0.addr_logic ptr = AddrLogic0.addr_logic result -> ptr = result }
    ensures { result = null_logic _1 }
    
  axiom null_logic_spec : forall _1 : () . ([#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 131 4 131 98] forall ptr : opaque_ptr . AddrLogic0.addr_logic ptr = AddrLogic0.addr_logic (null_logic _1) -> ptr = null_logic _1) && ([#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 129 4 129 64] forall t : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t . Inv0.inv t -> not Contains0.contains (ShallowModel0.shallow_model t) (null_logic _1))
end
module CreusotContracts_GhostPtr_Impl2_NullLogic
  type t
  use prelude.Opaque
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Stub as AddrLogic0 with
    type t = t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = t
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t
  function null_logic (_1 : ()) : opaque_ptr
  val null_logic (_1 : ()) : opaque_ptr
    ensures { [#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 129 4 129 64] forall t : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t . Inv0.inv t -> not Contains0.contains (ShallowModel0.shallow_model t) result }
    ensures { [#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 131 4 131 98] forall ptr : opaque_ptr . AddrLogic0.addr_logic ptr = AddrLogic0.addr_logic result -> ptr = result }
    ensures { result = null_logic _1 }
    
  axiom null_logic_spec : forall _1 : () . ([#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 131 4 131 98] forall ptr : opaque_ptr . AddrLogic0.addr_logic ptr = AddrLogic0.addr_logic (null_logic _1) -> ptr = null_logic _1) && ([#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 129 4 129 64] forall t : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t . Inv0.inv t -> not Contains0.contains (ShallowModel0.shallow_model t) (null_logic _1))
end
module CreusotContracts_Logic_Ops_Impl6_IndexLogic_Stub
  type t
  use prelude.Ghost
  use seq.Seq
  use prelude.Int
  function index_logic [@inline:trivial] (self : Ghost.ghost_ty (Seq.seq t)) (ix : int) : t
end
module CreusotContracts_Logic_Ops_Impl6_IndexLogic_Interface
  type t
  use prelude.Ghost
  use seq.Seq
  use prelude.Int
  function index_logic [@inline:trivial] (self : Ghost.ghost_ty (Seq.seq t)) (ix : int) : t
  val index_logic [@inline:trivial] (self : Ghost.ghost_ty (Seq.seq t)) (ix : int) : t
    ensures { result = index_logic self ix }
    
end
module CreusotContracts_Logic_Ops_Impl6_IndexLogic
  type t
  use prelude.Ghost
  use seq.Seq
  use prelude.Int
  function index_logic [@inline:trivial] (self : Ghost.ghost_ty (Seq.seq t)) (ix : int) : t =
    [#"/root/creusot/creusot-contracts/src/logic/ops.rs" 85 8 85 33] Seq.get (Ghost.inner self) ix
  val index_logic [@inline:trivial] (self : Ghost.ghost_ty (Seq.seq t)) (ix : int) : t
    ensures { result = index_logic self ix }
    
end
module CargoDir_LinkedList_Impl0_PrevOf_Stub
  type t
  use prelude.Int
  use prelude.Opaque
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  function prev_of [#"/root/milli/creusot/cargo-dir/src/lib.rs" 227 8 227 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    
end
module CargoDir_LinkedList_Impl0_PrevOf_Interface
  type t
  use prelude.Int
  use prelude.Opaque
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  function prev_of [#"/root/milli/creusot/cargo-dir/src/lib.rs" 227 8 227 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    
  val prev_of [#"/root/milli/creusot/cargo-dir/src/lib.rs" 227 8 227 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 226 19 226 25] i >= 0}
    ensures { result = prev_of self i }
    
end
module CargoDir_LinkedList_Impl0_PrevOf
  type t
  use prelude.Int
  use prelude.Opaque
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Stub as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic_Stub as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Stub as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  function prev_of [#"/root/milli/creusot/cargo-dir/src/lib.rs" 227 8 227 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    
   =
    [#"/root/milli/creusot/cargo-dir/src/lib.rs" 224 8 224 16] if i = 0 then
      NullLogic0.null_logic ()
    else
      IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) (i - 1)
    
  val prev_of [#"/root/milli/creusot/cargo-dir/src/lib.rs" 227 8 227 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 226 19 226 25] i >= 0}
    ensures { result = prev_of self i }
    
end
module CargoDir_LinkedList_Impl0_PrevOf_Impl
  type t
  use prelude.Int
  use prelude.Opaque
  use map.Map
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv1.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv1.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv2.inv
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  let rec ghost function prev_of [#"/root/milli/creusot/cargo-dir/src/lib.rs" 227 8 227 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 226 19 226 25] i >= 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/root/milli/creusot/cargo-dir/src/lib.rs" 224 8 224 16] if pure {i = 0} then
      NullLogic0.null_logic ()
    else
      IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) (i - 1)
    
end
module CargoDir_LinkedList_Impl0_NextOf_Stub
  type t
  use prelude.Int
  use prelude.Opaque
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  function next_of [#"/root/milli/creusot/cargo-dir/src/lib.rs" 238 8 238 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    
end
module CargoDir_LinkedList_Impl0_NextOf_Interface
  type t
  use prelude.Int
  use prelude.Opaque
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  function next_of [#"/root/milli/creusot/cargo-dir/src/lib.rs" 238 8 238 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    
  val next_of [#"/root/milli/creusot/cargo-dir/src/lib.rs" 238 8 238 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 237 19 237 25] i >= 0}
    ensures { result = next_of self i }
    
end
module CargoDir_LinkedList_Impl0_NextOf
  type t
  use prelude.Int
  use prelude.Opaque
  use prelude.Ghost
  use seq.Seq
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Stub as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic_Stub as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Stub as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  function next_of [#"/root/milli/creusot/cargo-dir/src/lib.rs" 238 8 238 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    
   =
    [#"/root/milli/creusot/cargo-dir/src/lib.rs" 235 8 235 16] if i + 1 = Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self)) then
      NullLogic0.null_logic ()
    else
      IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) (i + 1)
    
  val next_of [#"/root/milli/creusot/cargo-dir/src/lib.rs" 238 8 238 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 237 19 237 25] i >= 0}
    ensures { result = next_of self i }
    
end
module CargoDir_LinkedList_Impl0_NextOf_Impl
  type t
  use prelude.Int
  use prelude.Opaque
  use prelude.Ghost
  use seq.Seq
  use map.Map
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv1.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv1.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv2.inv
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  let rec ghost function next_of [#"/root/milli/creusot/cargo-dir/src/lib.rs" 238 8 238 50] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : opaque_ptr
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 237 19 237 25] i >= 0}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/root/milli/creusot/cargo-dir/src/lib.rs" 235 8 235 16] if pure {i + 1 = Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self))} then
      NullLogic0.null_logic ()
    else
      IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) (i + 1)
    
end
module CreusotContracts_Util_Unreachable_Stub
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  function unreachable (_1 : ()) : t
end
module CreusotContracts_Util_Unreachable_Interface
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  function unreachable (_1 : ()) : t
  val unreachable (_1 : ()) : t
    requires {[#"/root/creusot/creusot-contracts/src/util.rs" 24 11 24 16] false}
    ensures { [#"/root/creusot/creusot-contracts/src/util.rs" 25 10 25 15] false }
    ensures { [#"/root/creusot/creusot-contracts/src/util.rs" 27 0 27 28] Inv0.inv result }
    ensures { result = unreachable _1 }
    
  axiom unreachable_spec : forall _1 : () . ([#"/root/creusot/creusot-contracts/src/util.rs" 24 11 24 16] false) -> ([#"/root/creusot/creusot-contracts/src/util.rs" 27 0 27 28] Inv0.inv (unreachable _1)) && ([#"/root/creusot/creusot-contracts/src/util.rs" 25 10 25 15] false)
end
module CreusotContracts_Util_Unreachable
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  function unreachable (_1 : ()) : t
  val unreachable (_1 : ()) : t
    requires {[#"/root/creusot/creusot-contracts/src/util.rs" 24 11 24 16] false}
    ensures { [#"/root/creusot/creusot-contracts/src/util.rs" 25 10 25 15] false }
    ensures { [#"/root/creusot/creusot-contracts/src/util.rs" 27 0 27 28] Inv0.inv result }
    ensures { result = unreachable _1 }
    
  axiom def : forall _1 : () . unreachable _1 = ([#"/root/creusot/creusot-contracts/src/util.rs" 28 4 28 17] unreachable ())
  axiom unreachable_spec : forall _1 : () . ([#"/root/creusot/creusot-contracts/src/util.rs" 24 11 24 16] false) -> ([#"/root/creusot/creusot-contracts/src/util.rs" 27 0 27 28] Inv0.inv (unreachable _1)) && ([#"/root/creusot/creusot-contracts/src/util.rs" 25 10 25 15] false)
end
module CreusotContracts_Util_Unwrap_Stub
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Option_Option_Type.t_option t
  function unwrap (op : Core_Option_Option_Type.t_option t) : t
end
module CreusotContracts_Util_Unwrap_Interface
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Option_Option_Type.t_option t
  function unwrap (op : Core_Option_Option_Type.t_option t) : t
  val unwrap (op : Core_Option_Option_Type.t_option t) : t
    requires {[#"/root/creusot/creusot-contracts/src/util.rs" 33 11 33 21] op <> Core_Option_Option_Type.C_None}
    requires {[#"/root/creusot/creusot-contracts/src/util.rs" 35 17 35 19] Inv0.inv op}
    ensures { [#"/root/creusot/creusot-contracts/src/util.rs" 34 10 34 28] Core_Option_Option_Type.C_Some result = op }
    ensures { [#"/root/creusot/creusot-contracts/src/util.rs" 35 0 35 36] Inv1.inv result }
    ensures { result = unwrap op }
    
  axiom unwrap_spec : forall op : Core_Option_Option_Type.t_option t . ([#"/root/creusot/creusot-contracts/src/util.rs" 33 11 33 21] op <> Core_Option_Option_Type.C_None) -> ([#"/root/creusot/creusot-contracts/src/util.rs" 35 17 35 19] Inv0.inv op) -> ([#"/root/creusot/creusot-contracts/src/util.rs" 35 0 35 36] Inv1.inv (unwrap op)) && ([#"/root/creusot/creusot-contracts/src/util.rs" 34 10 34 28] Core_Option_Option_Type.C_Some (unwrap op) = op)
end
module CreusotContracts_Util_Unwrap
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Util_Unreachable_Stub as Unreachable0 with
    type t = t,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Option_Option_Type.t_option t
  function unwrap (op : Core_Option_Option_Type.t_option t) : t =
    [#"/root/creusot/creusot-contracts/src/util.rs" 36 4 39 5] match (op) with
      | Core_Option_Option_Type.C_Some t -> t
      | Core_Option_Option_Type.C_None -> Unreachable0.unreachable ()
      end
  val unwrap (op : Core_Option_Option_Type.t_option t) : t
    requires {[#"/root/creusot/creusot-contracts/src/util.rs" 33 11 33 21] op <> Core_Option_Option_Type.C_None}
    requires {[#"/root/creusot/creusot-contracts/src/util.rs" 35 17 35 19] Inv0.inv op}
    ensures { [#"/root/creusot/creusot-contracts/src/util.rs" 34 10 34 28] Core_Option_Option_Type.C_Some result = op }
    ensures { [#"/root/creusot/creusot-contracts/src/util.rs" 35 0 35 36] Inv1.inv result }
    ensures { result = unwrap op }
    
  axiom unwrap_spec : forall op : Core_Option_Option_Type.t_option t . ([#"/root/creusot/creusot-contracts/src/util.rs" 33 11 33 21] op <> Core_Option_Option_Type.C_None) -> ([#"/root/creusot/creusot-contracts/src/util.rs" 35 17 35 19] Inv0.inv op) -> ([#"/root/creusot/creusot-contracts/src/util.rs" 35 0 35 36] Inv1.inv (unwrap op)) && ([#"/root/creusot/creusot-contracts/src/util.rs" 34 10 34 28] Core_Option_Option_Type.C_Some (unwrap op) = op)
end
module CreusotContracts_Logic_Fmap_Impl0_LookupUnsized_Stub
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function lookup_unsized (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : v
end
module CreusotContracts_Logic_Fmap_Impl0_LookupUnsized_Interface
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function lookup_unsized (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : v
  val lookup_unsized (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : v
    ensures { result = lookup_unsized self k }
    
end
module CreusotContracts_Logic_Fmap_Impl0_LookupUnsized
  type k
  type v
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = v
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = Core_Option_Option_Type.t_option v
  clone CreusotContracts_Util_Unwrap_Stub as Unwrap0 with
    type t = v,
    predicate Inv0.inv = Inv0.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Get_Stub as Get0 with
    type k = k,
    type v = v
  function lookup_unsized (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : v =
    [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 61 8 61 27] Unwrap0.unwrap (Get0.get self k)
  val lookup_unsized (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : v
    ensures { result = lookup_unsized self k }
    
end
module CreusotContracts_Logic_Fmap_Impl0_Lookup_Stub
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function lookup [@inline:trivial] (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : v
end
module CreusotContracts_Logic_Fmap_Impl0_Lookup_Interface
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function lookup [@inline:trivial] (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : v
  val lookup [@inline:trivial] (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : v
    ensures { result = lookup self k }
    
end
module CreusotContracts_Logic_Fmap_Impl0_Lookup
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized_Stub as LookupUnsized0 with
    type k = k,
    type v = v
  function lookup [@inline:trivial] (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : v =
    [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 71 9 71 31] LookupUnsized0.lookup_unsized self k
  val lookup [@inline:trivial] (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : v
    ensures { result = lookup self k }
    
end
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type t_nonnull 't =
    | C_NonNull opaque_ptr
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_unique 't =
    | C_Unique (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (Core_Marker_PhantomData_Type.t_phantomdata 't)
    
end
module Alloc_Boxed_Box_Type
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  type t_box 't 'a =
    | C_Box (Core_Ptr_Unique_Unique_Type.t_unique 't) 'a
    
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
    
end
module CargoDir_LinkedList_Impl0_WfToken_Stub
  type t
  use prelude.Int
  use prelude.Ghost
  use seq.Seq
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  predicate wf_token [#"/root/milli/creusot/cargo-dir/src/lib.rs" 249 8 249 41] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int)
    
end
module CargoDir_LinkedList_Impl0_WfToken_Interface
  type t
  use prelude.Int
  use prelude.Ghost
  use seq.Seq
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  predicate wf_token [#"/root/milli/creusot/cargo-dir/src/lib.rs" 249 8 249 41] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int)
    
  val wf_token [#"/root/milli/creusot/cargo-dir/src/lib.rs" 249 8 249 41] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : bool
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 248 19 248 48] i >= 0 /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self))}
    ensures { result = wf_token self i }
    
end
module CargoDir_LinkedList_Impl0_WfToken
  type t
  use prelude.Int
  use prelude.Ghost
  use seq.Seq
  use prelude.Opaque
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_NextOf_Stub as NextOf0 with
    type t = t,
    axiom .
  clone CargoDir_LinkedList_Impl0_PrevOf_Stub as PrevOf0 with
    type t = t,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup_Stub as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic_Stub as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  predicate wf_token [#"/root/milli/creusot/cargo-dir/src/lib.rs" 249 8 249 41] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int)
    
   =
    [#"/root/milli/creusot/cargo-dir/src/lib.rs" 246 8 246 20] Contains0.contains (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token self)) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) i) /\ CargoDir_LinkedList_Node_Type.node_prev (Lookup0.lookup (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token self)) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) i)) = PrevOf0.prev_of self i /\ CargoDir_LinkedList_Node_Type.node_next (Lookup0.lookup (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token self)) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) i)) = NextOf0.next_of self i
  val wf_token [#"/root/milli/creusot/cargo-dir/src/lib.rs" 249 8 249 41] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int) : bool
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 248 19 248 48] i >= 0 /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self))}
    ensures { result = wf_token self i }
    
end
module CargoDir_LinkedList_Impl0_WfToken_Impl
  type t
  use prelude.Int
  use prelude.Ghost
  use seq.Seq
  use map.Map
  use prelude.Opaque
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Util_Unwrap_Interface as Unwrap0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv1.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv1.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv2.inv
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized as LookupUnsized0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get,
    function Unwrap0.unwrap = Unwrap0.unwrap,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv4.inv
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_NextOf as NextOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_PrevOf as PrevOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized
  let rec ghost predicate wf_token [#"/root/milli/creusot/cargo-dir/src/lib.rs" 249 8 249 41] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) (i : int)
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 248 19 248 48] i >= 0 /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self))}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/root/milli/creusot/cargo-dir/src/lib.rs" 246 8 246 20] (let a' = ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token self) in let b' = IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) i in Contains0.contains a' b') && (let b = PrevOf0.prev_of self i in let a = CargoDir_LinkedList_Node_Type.node_prev (let a' = ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token self) in let b' = IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) i in Lookup0.lookup a' b') in pure {a = b}) && (let b = NextOf0.next_of self i in let a = CargoDir_LinkedList_Node_Type.node_next (let a' = ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token self) in let b' = IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) i in Lookup0.lookup a' b') in pure {a = b})
end
module CargoDir_LinkedList_Impl0_Invariant_Stub
  type t
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  predicate invariant' [#"/root/milli/creusot/cargo-dir/src/lib.rs" 257 8 257 38] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
    
end
module CargoDir_LinkedList_Impl0_Invariant_Interface
  type t
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  predicate invariant' [#"/root/milli/creusot/cargo-dir/src/lib.rs" 257 8 257 38] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
    
  val invariant' [#"/root/milli/creusot/cargo-dir/src/lib.rs" 257 8 257 38] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) : bool
    ensures { result = invariant' self }
    
end
module CargoDir_LinkedList_Impl0_Invariant
  type t
  use prelude.Int
  use prelude.Ghost
  use seq.Seq
  use prelude.Opaque
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Stub as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic_Stub as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Stub as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_WfToken_Stub as WfToken0 with
    type t = t,
    axiom .
  predicate invariant' [#"/root/milli/creusot/cargo-dir/src/lib.rs" 257 8 257 38] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
    
   =
    [#"/root/milli/creusot/cargo-dir/src/lib.rs" 258 12 267 13] (forall i : int . 0 <= i /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self)) -> WfToken0.wf_token self i) /\ (if Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self)) = 0 then
      CargoDir_LinkedList_LinkedList_Type.linkedlist_head self = NullLogic0.null_logic () /\ CargoDir_LinkedList_LinkedList_Type.linkedlist_tail self = NullLogic0.null_logic ()
    else
      CargoDir_LinkedList_LinkedList_Type.linkedlist_head self = IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) 0 /\ CargoDir_LinkedList_LinkedList_Type.linkedlist_tail self = IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self)) - 1)
    )
  val invariant' [#"/root/milli/creusot/cargo-dir/src/lib.rs" 257 8 257 38] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) : bool
    ensures { result = invariant' self }
    
end
module CargoDir_LinkedList_Impl0_Model_Stub
  type t
  use seq.Seq
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  function model [#"/root/milli/creusot/cargo-dir/src/lib.rs" 272 8 272 36] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) : Seq.seq t
    
end
module CargoDir_LinkedList_Impl0_Model_Interface
  type t
  use seq.Seq
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  function model [#"/root/milli/creusot/cargo-dir/src/lib.rs" 272 8 272 36] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) : Seq.seq t
    
  val model [#"/root/milli/creusot/cargo-dir/src/lib.rs" 272 8 272 36] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) : Seq.seq t
    ensures { result = model self }
    
end
module CargoDir_LinkedList_Impl0_Model
  type t
  use seq.Seq
  use prelude.Ghost
  use prelude.Int
  use prelude.Mapping
  use prelude.Opaque
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup_Stub as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic_Stub as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  function model [#"/root/milli/creusot/cargo-dir/src/lib.rs" 272 8 272 36] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) : Seq.seq t
    
   =
    [#"/root/milli/creusot/cargo-dir/src/lib.rs" 274 16 275 77] Seq.create (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self))) (Mapping.from_fn (fun (i : int) -> CargoDir_LinkedList_Node_Type.node_data (Lookup0.lookup (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token self)) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self) i))))
  val model [#"/root/milli/creusot/cargo-dir/src/lib.rs" 272 8 272 36] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) : Seq.seq t
    ensures { result = model self }
    
end
module Core_Ptr_Null_Interface
  type t
  use prelude.Opaque
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Stub as AddrLogic0 with
    type t = t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = t
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Stub as NullLogic0 with
    type t = t,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  val null (_1 : ()) : opaque_ptr
    ensures { [#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 169 22 169 59] result = NullLogic0.null_logic () }
    
end
module CreusotContracts_Logic_Fmap_Impl0_Len_Stub
  type k
  type v
  use prelude.Int
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  function len (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : int
end
module CreusotContracts_Logic_Fmap_Impl0_Len_Interface
  type k
  type v
  use prelude.Int
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  function len (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : int
  val len (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : int
    requires {[#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 13 15 13 19] Inv0.inv self}
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 12 14 12 25] result >= 0 }
    ensures { result = len self }
    
  axiom len_spec : forall self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v . ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 13 15 13 19] Inv0.inv self) -> ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 12 14 12 25] len self >= 0)
end
module CreusotContracts_Logic_Fmap_Impl0_Len
  type k
  type v
  use prelude.Int
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  function len (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : int
  val len (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : int
    requires {[#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 13 15 13 19] Inv0.inv self}
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 12 14 12 25] result >= 0 }
    ensures { result = len self }
    
  axiom len_spec : forall self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v . ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 13 15 13 19] Inv0.inv self) -> ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 12 14 12 25] len self >= 0)
end
module CreusotContracts_Logic_Fmap_Impl0_Empty_Stub
  type k
  type v
  use map.Const
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  function empty (_1 : ()) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
end
module CreusotContracts_Logic_Fmap_Impl0_Empty_Interface
  type k
  type v
  use map.Const
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  function empty (_1 : ()) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  val empty (_1 : ()) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 83 14 83 31] Len0.len result = 0 }
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 84 14 84 49] View0.view result = Const.const (Core_Option_Option_Type.C_None) }
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 85 4 85 26] Inv0.inv result }
    ensures { result = empty _1 }
    
  axiom empty_spec : forall _1 : () . ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 85 4 85 26] Inv0.inv (empty _1)) && ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 84 14 84 49] View0.view (empty _1) = Const.const (Core_Option_Option_Type.C_None)) && ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 83 14 83 31] Len0.len (empty _1) = 0)
end
module CreusotContracts_Logic_Fmap_Impl0_Empty
  type k
  type v
  use map.Const
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  function empty (_1 : ()) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  val empty (_1 : ()) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 83 14 83 31] Len0.len result = 0 }
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 84 14 84 49] View0.view result = Const.const (Core_Option_Option_Type.C_None) }
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 85 4 85 26] Inv0.inv result }
    ensures { result = empty _1 }
    
  axiom empty_spec : forall _1 : () . ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 85 4 85 26] Inv0.inv (empty _1)) && ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 84 14 84 49] View0.view (empty _1) = Const.const (Core_Option_Option_Type.C_None)) && ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 83 14 83 31] Len0.len (empty _1) = 0)
end
module CreusotContracts_GhostPtr_Impl1_New_Interface
  type t
  use map.Map
  use prelude.Opaque
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option t)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv1.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t
  clone CreusotContracts_Logic_Fmap_Impl0_Empty_Stub as Empty0 with
    type k = opaque_ptr,
    type v = t,
    function Len0.len = Len0.len,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv1.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t
  val new (_1 : ()) : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t
    ensures { [#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 27 14 27 38] ShallowModel0.shallow_model result = Empty0.empty () }
    ensures { [#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 28 4 28 24] Inv0.inv result }
    
end
module CargoDir_LinkedList_Impl0_New_Interface
  type t
  use seq.Seq
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone CargoDir_LinkedList_Impl0_Model_Stub as Model0 with
    type t = t
  clone CargoDir_LinkedList_Impl0_Invariant_Stub as Invariant0 with
    type t = t
  val new [#"/root/milli/creusot/cargo-dir/src/lib.rs" 293 8 293 28] (_1 : ()) : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 291 18 291 36] Invariant0.invariant' result }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 292 18 292 46] Model0.model result = Seq.empty  }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 293 24 293 28] Inv0.inv result }
    
end
module CargoDir_LinkedList_Impl0_New
  type t
  use seq.Seq
  use prelude.Ghost
  use prelude.Opaque
  use map.Map
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv5.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Util_Unwrap_Interface as Unwrap0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv2.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv2.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv3.inv
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_NextOf as NextOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_PrevOf as PrevOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized as LookupUnsized0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get,
    function Unwrap0.unwrap = Unwrap0.unwrap,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv5.inv
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized
  clone CargoDir_LinkedList_Impl0_WfToken as WfToken0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Contains0.contains = Contains0.contains,
    function Lookup0.lookup = Lookup0.lookup,
    function PrevOf0.prev_of = PrevOf0.prev_of,
    function NextOf0.next_of = NextOf0.next_of,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Interface as Len0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Empty_Interface as Empty0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Len0.len = Len0.len,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv2.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CargoDir_LinkedList_Impl0_Invariant as Invariant0 with
    type t = t,
    predicate WfToken0.wf_token = WfToken0.wf_token,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CargoDir_LinkedList_Impl0_Model as Model0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Lookup0.lookup = Lookup0.lookup
  clone CreusotContracts_GhostPtr_Impl1_New_Interface as New0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Empty0.empty = Empty0.empty,
    predicate Inv0.inv = Inv1.inv,
    function Len0.len = Len0.len,
    function View0.view = View0.view,
    predicate Inv1.inv = Inv2.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv2.inv = Inv3.inv
  clone Core_Ptr_Null_Interface as Null0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  let rec cfg new [#"/root/milli/creusot/cargo-dir/src/lib.rs" 293 8 293 28] [@cfg:stackify] [@cfg:subregion_analysis] (_1 : ()) : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 291 18 291 36] Invariant0.invariant' result }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 292 18 292 46] Model0.model result = Seq.empty  }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 293 24 293 28] Inv0.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t;
  var this : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t;
  var _4 : opaque_ptr;
  var _5 : opaque_ptr;
  var _6 : Ghost.ghost_ty (Seq.seq opaque_ptr);
  var _8 : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t);
  {
    goto BB0
  }
  BB0 {
    _4 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 295 22 295 33] Null0.null ());
    goto BB1
  }
  BB1 {
    _5 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 296 22 296 33] Null0.null ());
    goto BB2
  }
  BB2 {
    _6 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 297 22 297 37] Ghost.new (Seq.empty ));
    goto BB3
  }
  BB3 {
    _8 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 298 23 298 43] New0.new ());
    goto BB4
  }
  BB4 {
    this <- CargoDir_LinkedList_LinkedList_Type.C_LinkedList _4 _5 _6 _8;
    _4 <- any opaque_ptr;
    _5 <- any opaque_ptr;
    _6 <- any Ghost.ghost_ty (Seq.seq opaque_ptr);
    _8 <- any CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t);
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 300 26 300 57] Seq.(==) (Model0.model this) (Seq.empty ) };
    _0 <- this;
    this <- any CargoDir_LinkedList_LinkedList_Type.t_linkedlist t;
    return _0
  }
  
end
module CreusotContracts_Resolve_Resolve_Resolve_Stub
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Resolve_Resolve_Resolve_Interface
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Resolve_Resolve
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Util_Impl0_MakeSized_Stub
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  function make_sized (self : t) : t
end
module CreusotContracts_Util_Impl0_MakeSized_Interface
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  function make_sized (self : t) : t
  val make_sized (self : t) : t
    requires {[#"/root/creusot/creusot-contracts/src/util.rs" 16 18 16 22] Inv0.inv self}
    ensures { [#"/root/creusot/creusot-contracts/src/util.rs" 15 14 15 29] result = self }
    ensures { [#"/root/creusot/creusot-contracts/src/util.rs" 16 4 16 39] Inv1.inv result }
    ensures { result = make_sized self }
    
  axiom make_sized_spec : forall self : t . ([#"/root/creusot/creusot-contracts/src/util.rs" 16 18 16 22] Inv0.inv self) -> ([#"/root/creusot/creusot-contracts/src/util.rs" 16 4 16 39] Inv1.inv (make_sized self)) && ([#"/root/creusot/creusot-contracts/src/util.rs" 15 14 15 29] make_sized self = self)
end
module CreusotContracts_Util_Impl0_MakeSized
  type t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  function make_sized (self : t) : t
  val make_sized (self : t) : t
    requires {[#"/root/creusot/creusot-contracts/src/util.rs" 16 18 16 22] Inv0.inv self}
    ensures { [#"/root/creusot/creusot-contracts/src/util.rs" 15 14 15 29] result = self }
    ensures { [#"/root/creusot/creusot-contracts/src/util.rs" 16 4 16 39] Inv1.inv result }
    ensures { result = make_sized self }
    
  axiom make_sized_spec : forall self : t . ([#"/root/creusot/creusot-contracts/src/util.rs" 16 18 16 22] Inv0.inv self) -> ([#"/root/creusot/creusot-contracts/src/util.rs" 16 4 16 39] Inv1.inv (make_sized self)) && ([#"/root/creusot/creusot-contracts/src/util.rs" 15 14 15 29] make_sized self = self)
end
module CreusotContracts_Logic_Fmap_Impl0_Insert_Stub
  type k
  type v
  use map.Map
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = v
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = v
  clone CreusotContracts_Util_Impl0_MakeSized_Stub as MakeSized0 with
    type t = v,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  function insert (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) (v : v) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    
end
module CreusotContracts_Logic_Fmap_Impl0_Insert_Interface
  type k
  type v
  use map.Map
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = v
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = v
  clone CreusotContracts_Util_Impl0_MakeSized_Stub as MakeSized0 with
    type t = v,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  function insert (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) (v : v) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    
  val insert (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) (v : v) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    requires {[#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 38 18 38 22] Inv0.inv self}
    requires {[#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 38 24 38 25] Inv1.inv k}
    requires {[#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 38 30 38 31] Inv2.inv v}
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 35 14 35 71] View0.view result = Map.set (View0.view self) k (Core_Option_Option_Type.C_Some (MakeSized0.make_sized v)) }
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 36 4 36 63] Contains0.contains self k -> Len0.len result = Len0.len self }
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 37 4 37 68] not Contains0.contains self k -> Len0.len result = Len0.len self + 1 }
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 38 4 38 43] Inv0.inv result }
    ensures { result = insert self k v }
    
  axiom insert_spec : forall self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v, k : k, v : v . ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 38 18 38 22] Inv0.inv self) -> ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 38 24 38 25] Inv1.inv k) -> ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 38 30 38 31] Inv2.inv v) -> ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 38 4 38 43] Inv0.inv (insert self k v)) && ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 37 4 37 68] not Contains0.contains self k -> Len0.len (insert self k v) = Len0.len self + 1) && ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 36 4 36 63] Contains0.contains self k -> Len0.len (insert self k v) = Len0.len self) && ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 35 14 35 71] View0.view (insert self k v) = Map.set (View0.view self) k (Core_Option_Option_Type.C_Some (MakeSized0.make_sized v)))
end
module CreusotContracts_Logic_Fmap_Impl0_Insert
  type k
  type v
  use map.Map
  use prelude.Int
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = v
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = v
  clone CreusotContracts_Util_Impl0_MakeSized_Stub as MakeSized0 with
    type t = v,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  function insert (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) (v : v) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    
  val insert (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) (v : v) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    requires {[#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 38 18 38 22] Inv0.inv self}
    requires {[#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 38 24 38 25] Inv1.inv k}
    requires {[#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 38 30 38 31] Inv2.inv v}
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 35 14 35 71] View0.view result = Map.set (View0.view self) k (Core_Option_Option_Type.C_Some (MakeSized0.make_sized v)) }
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 36 4 36 63] Contains0.contains self k -> Len0.len result = Len0.len self }
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 37 4 37 68] not Contains0.contains self k -> Len0.len result = Len0.len self + 1 }
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 38 4 38 43] Inv0.inv result }
    ensures { result = insert self k v }
    
  axiom insert_spec : forall self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v, k : k, v : v . ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 38 18 38 22] Inv0.inv self) -> ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 38 24 38 25] Inv1.inv k) -> ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 38 30 38 31] Inv2.inv v) -> ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 38 4 38 43] Inv0.inv (insert self k v)) && ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 37 4 37 68] not Contains0.contains self k -> Len0.len (insert self k v) = Len0.len self + 1) && ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 36 4 36 63] Contains0.contains self k -> Len0.len (insert self k v) = Len0.len self) && ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 35 14 35 71] View0.view (insert self k v) = Map.set (View0.view self) k (Core_Option_Option_Type.C_Some (MakeSized0.make_sized v)))
end
module CreusotContracts_GhostPtr_Impl1_PtrFromBox_Interface
  type t
  use prelude.Borrow
  use prelude.Opaque
  use map.Map
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Stub as AddrLogic0 with
    type t = t
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv6 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option t)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = t
  clone CreusotContracts_Util_Impl0_MakeSized_Stub as MakeSized0 with
    type t = t,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv2.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = opaque_ptr
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Stub as NullLogic0 with
    type t = t,
    predicate Inv0.inv = Inv6.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Insert_Stub as Insert0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv3.inv,
    predicate Inv2.inv = Inv4.inv,
    function View0.view = View0.view,
    function MakeSized0.make_sized = MakeSized0.make_sized,
    function Contains0.contains = Contains0.contains,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv3.inv = Inv5.inv,
    predicate Inv4.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t)
  val ptr_from_box (self : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t)) (val' : t) : opaque_ptr
    requires {[#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 58 29 58 33] Inv0.inv self}
    requires {[#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 58 35 58 38] Inv1.inv val'}
    ensures { [#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 53 4 53 42] not Contains0.contains (ShallowModel0.shallow_model ( * self)) result }
    ensures { [#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 56 14 56 55] ShallowModel0.shallow_model ( ^ self) = Insert0.insert (ShallowModel0.shallow_model ( * self)) result val' }
    ensures { [#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 57 14 57 46] result <> NullLogic0.null_logic () }
    
end
module CargoDir_LinkedList_Impl0_Singleton_Interface
  type t
  use seq.Seq
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone CargoDir_LinkedList_Impl0_Model_Stub as Model0 with
    type t = t
  clone CargoDir_LinkedList_Impl0_Invariant_Stub as Invariant0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = t
  val singleton [#"/root/milli/creusot/cargo-dir/src/lib.rs" 306 8 306 38] (v : t) : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 306 25 306 26] Inv0.inv v}
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 304 18 304 36] Invariant0.invariant' result }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 305 18 305 58] Seq.(==) (Model0.model result) (Seq.singleton v) }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 306 34 306 38] Inv1.inv result }
    
end
module CargoDir_LinkedList_Impl0_Singleton
  type t
  use prelude.Opaque
  use prelude.Borrow
  use seq.Seq
  use prelude.Ghost
  use map.Map
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Util_Unwrap_Interface as Unwrap0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv6.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv3.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv3.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv4.inv
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized as LookupUnsized0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get,
    function Unwrap0.unwrap = Unwrap0.unwrap,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv6.inv
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_NextOf as NextOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_PrevOf as PrevOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = opaque_ptr
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = opaque_ptr,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized
  clone CargoDir_LinkedList_Impl0_WfToken as WfToken0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Contains0.contains = Contains0.contains,
    function Lookup0.lookup = Lookup0.lookup,
    function PrevOf0.prev_of = PrevOf0.prev_of,
    function NextOf0.next_of = NextOf0.next_of,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = t
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = t,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Util_Impl0_MakeSized_Interface as MakeSized0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv8.inv,
    predicate Inv1.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Interface as Len0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Insert_Interface as Insert0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv3.inv,
    predicate Inv1.inv = Inv7.inv,
    predicate Inv2.inv = Inv8.inv,
    function View0.view = View0.view,
    function MakeSized0.make_sized = MakeSized0.make_sized,
    function Contains0.contains = Contains0.contains,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv3.inv = Inv4.inv,
    predicate Inv4.inv = Inv6.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Empty_Interface as Empty0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Len0.len = Len0.len,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv3.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CargoDir_LinkedList_Impl0_Model as Model0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Lookup0.lookup = Lookup0.lookup
  clone CargoDir_LinkedList_Impl0_Invariant as Invariant0 with
    type t = t,
    predicate WfToken0.wf_token = WfToken0.wf_token,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl1_PtrFromBox_Interface as PtrFromBox0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv5.inv,
    predicate Inv1.inv = Inv6.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function Insert0.insert = Insert0.insert,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    predicate Inv2.inv = Inv3.inv,
    predicate Inv3.inv = Inv7.inv,
    predicate Inv4.inv = Inv8.inv,
    function View0.view = View0.view,
    function MakeSized0.make_sized = MakeSized0.make_sized,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv5.inv = Inv4.inv,
    predicate Inv6.inv = Inv0.inv,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone Core_Ptr_Null_Interface as Null0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_GhostPtr_Impl1_New_Interface as New0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Empty0.empty = Empty0.empty,
    predicate Inv0.inv = Inv0.inv,
    function Len0.len = Len0.len,
    function View0.view = View0.view,
    predicate Inv1.inv = Inv3.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv2.inv = Inv4.inv
  let rec cfg singleton [#"/root/milli/creusot/cargo-dir/src/lib.rs" 306 8 306 38] [@cfg:stackify] [@cfg:subregion_analysis] (v : t) : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 306 25 306 26] Inv1.inv v}
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 304 18 304 36] Invariant0.invariant' result }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 305 18 305 58] Seq.(==) (Model0.model result) (Seq.singleton v) }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 306 34 306 38] Inv2.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t;
  var v : t = v;
  var token : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t);
  var node : CargoDir_LinkedList_Node_Type.t_node t;
  var _7 : opaque_ptr;
  var _8 : opaque_ptr;
  var ptr : opaque_ptr;
  var _10 : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
  var _15 : Ghost.ghost_ty (Seq.seq opaque_ptr);
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    token <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 308 28 308 48] New0.new ());
    goto BB2
  }
  BB2 {
    _7 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 311 22 311 33] Null0.null ());
    goto BB3
  }
  BB3 {
    _8 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 312 22 312 33] Null0.null ());
    goto BB4
  }
  BB4 {
    node <- CargoDir_LinkedList_Node_Type.C_Node v _7 _8;
    v <- any t;
    _7 <- any opaque_ptr;
    _8 <- any opaque_ptr;
    goto BB5
  }
  BB5 {
    _10 <- Borrow.borrow_mut token;
    token <-  ^ _10;
    assume { Inv0.inv ( ^ _10) };
    goto BB6
  }
  BB6 {
    ptr <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 314 22 314 56] PtrFromBox0.ptr_from_box _10 node);
    _10 <- any borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
    node <- any CargoDir_LinkedList_Node_Type.t_node t;
    goto BB7
  }
  BB7 {
    assume { Resolve0.resolve ptr };
    _15 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 318 22 318 46] Ghost.new (Seq.singleton ptr));
    goto BB8
  }
  BB8 {
    _0 <- CargoDir_LinkedList_LinkedList_Type.C_LinkedList ptr ptr _15 token;
    _15 <- any Ghost.ghost_ty (Seq.seq opaque_ptr);
    token <- any CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t);
    goto BB9
  }
  BB9 {
    goto BB10
  }
  BB10 {
    return _0
  }
  
end
module CreusotContracts_Logic_Fmap_Impl0_Subset_Stub
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function subset (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : bool
    
end
module CreusotContracts_Logic_Fmap_Impl0_Subset_Interface
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function subset (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : bool
    
  val subset (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : bool
    ensures { result = subset self other }
    
end
module CreusotContracts_Logic_Fmap_Impl0_Subset
  type k
  type v
  use Core_Option_Option_Type as Core_Option_Option_Type
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Get_Stub as Get0 with
    type k = k,
    type v = v
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = k
  function subset (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : bool
    
   =
    [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 104 8 104 81] forall k : k . Inv0.inv k -> Contains0.contains self k -> Get0.get other k = Get0.get self k
  val subset (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : bool
    ensures { result = subset self other }
    
end
module CreusotContracts_Resolve_Impl1_Resolve_Stub
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve_Interface
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Resolve_Impl1_Resolve
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t) =
    [#"/root/creusot/creusot-contracts/src/resolve.rs" 25 20 25 34]  ^ self =  * self
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module Core_Ptr_ConstPtr_Impl0_IsNull_Interface
  type t
  use prelude.Opaque
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Stub as AddrLogic0 with
    type t = t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = t
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Stub as NullLogic0 with
    type t = t,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  val is_null (self : opaque_ptr) : bool
    ensures { [#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 160 18 160 65] result = (self = NullLogic0.null_logic ()) }
    
end
module CreusotContracts_Logic_Fmap_Impl0_Remove_Stub
  type k
  type v
  use map.Map
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  function remove (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    
end
module CreusotContracts_Logic_Fmap_Impl0_Remove_Interface
  type k
  type v
  use map.Map
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  function remove (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    
  val remove (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    requires {[#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 47 18 47 22] Inv0.inv self}
    requires {[#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 47 24 47 25] Inv1.inv k}
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 45 14 45 55] View0.view result = Map.set (View0.view self) k (Core_Option_Option_Type.C_None) }
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 46 14 46 84] Len0.len result = (if Contains0.contains self k then
      Len0.len self - 1
    else
      Len0.len self
    ) }
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 47 4 47 37] Inv0.inv result }
    ensures { result = remove self k }
    
  axiom remove_spec : forall self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v, k : k . ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 47 18 47 22] Inv0.inv self) -> ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 47 24 47 25] Inv1.inv k) -> ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 47 4 47 37] Inv0.inv (remove self k)) && ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 46 14 46 84] Len0.len (remove self k) = (if Contains0.contains self k then
    Len0.len self - 1
  else
    Len0.len self
  )) && ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 45 14 45 55] View0.view (remove self k) = Map.set (View0.view self) k (Core_Option_Option_Type.C_None))
end
module CreusotContracts_Logic_Fmap_Impl0_Remove
  type k
  type v
  use map.Map
  use prelude.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = Map.map k (Core_Option_Option_Type.t_option v)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = k,
    type v = v
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  function remove (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    
  val remove (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (k : k) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    requires {[#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 47 18 47 22] Inv0.inv self}
    requires {[#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 47 24 47 25] Inv1.inv k}
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 45 14 45 55] View0.view result = Map.set (View0.view self) k (Core_Option_Option_Type.C_None) }
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 46 14 46 84] Len0.len result = (if Contains0.contains self k then
      Len0.len self - 1
    else
      Len0.len self
    ) }
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 47 4 47 37] Inv0.inv result }
    ensures { result = remove self k }
    
  axiom remove_spec : forall self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v, k : k . ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 47 18 47 22] Inv0.inv self) -> ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 47 24 47 25] Inv1.inv k) -> ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 47 4 47 37] Inv0.inv (remove self k)) && ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 46 14 46 84] Len0.len (remove self k) = (if Contains0.contains self k then
    Len0.len self - 1
  else
    Len0.len self
  )) && ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 45 14 45 55] View0.view (remove self k) = Map.set (View0.view self) k (Core_Option_Option_Type.C_None))
end
module CreusotContracts_GhostPtr_Impl1_PtrToBox_Interface
  type t
  use prelude.Borrow
  use prelude.Opaque
  use map.Map
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option t)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv2.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = opaque_ptr
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Logic_Fmap_Impl0_Remove_Stub as Remove0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv3.inv,
    function View0.view = View0.view,
    function Len0.len = Len0.len,
    function Contains0.contains = Contains0.contains,
    function Mk0.mk = Mk0.mk,
    predicate Inv2.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized_Stub as LookupUnsized0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t)
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t
  val ptr_to_box (self : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t)) (ptr : opaque_ptr) : t
    requires {[#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 106 4 106 39] Contains0.contains (ShallowModel0.shallow_model ( * self)) ptr}
    requires {[#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 109 27 109 31] Inv0.inv self}
    ensures { [#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 107 14 107 54] result = LookupUnsized0.lookup_unsized (ShallowModel0.shallow_model ( * self)) ptr }
    ensures { [#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 108 14 108 46] ShallowModel0.shallow_model ( ^ self) = Remove0.remove (ShallowModel0.shallow_model ( * self)) ptr }
    ensures { [#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 109 4 109 57] Inv1.inv result }
    
end
module CreusotContracts_Model_ShallowModel_ShallowModelTy_Type
  type self
  type shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Stub
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Interface
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_ShallowModel_ShallowModel
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl7_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl7_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl7_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy =
    [#"/root/creusot/creusot-contracts/src/model.rs" 101 8 101 31] ShallowModel0.shallow_model ( * self)
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_GhostPtr_Impl1_PtrAsMut_Interface
  type t
  use prelude.Borrow
  use prelude.Opaque
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv6 with
    type t = t
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Stub as Inv5 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option t)
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Stub as Mk0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv4 with
    type t = t
  clone CreusotContracts_Util_Impl0_MakeSized_Stub as MakeSized0 with
    type t = t,
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_View_Stub as View0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv2.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = opaque_ptr
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = borrowed t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Logic_Fmap_Impl0_Insert_Stub as Insert0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv3.inv,
    predicate Inv2.inv = Inv4.inv,
    function View0.view = View0.view,
    function MakeSized0.make_sized = MakeSized0.make_sized,
    function Contains0.contains = Contains0.contains,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv3.inv = Inv5.inv,
    predicate Inv4.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized_Stub as LookupUnsized0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t)
  clone CreusotContracts_Model_Impl7_ShallowModel_Stub as ShallowModel0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t,
    type ShallowModelTy0.shallowModelTy = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
  val ptr_as_mut (self : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t)) (ptr : opaque_ptr) : borrowed t
    requires {[#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 95 4 95 36] Contains0.contains (ShallowModel0.shallow_model self) ptr}
    requires {[#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 98 27 98 31] Inv0.inv self}
    ensures { [#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 96 14 96 54]  * result = LookupUnsized0.lookup_unsized (ShallowModel1.shallow_model ( * self)) ptr }
    ensures { [#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 97 14 97 55] ShallowModel1.shallow_model ( ^ self) = Insert0.insert (ShallowModel1.shallow_model ( * self)) ptr ( ^ result) }
    ensures { [#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 98 4 98 57] Inv1.inv result }
    
end
module CargoDir_LinkedList_Impl0_PopFront_Interface
  type t
  use prelude.Borrow
  use seq.Seq
  use prelude.Int
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone CargoDir_LinkedList_Impl0_Model_Stub as Model0 with
    type t = t
  clone CargoDir_LinkedList_Impl0_Invariant_Stub as Invariant0 with
    type t = t
  val pop_front [#"/root/milli/creusot/cargo-dir/src/lib.rs" 328 8 328 40] (self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)) : t
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 324 19 324 38] Invariant0.invariant' ( * self)}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 325 19 325 44] Seq.length (Model0.model ( * self)) > 0}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 328 30 328 34] Inv0.inv self}
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 326 18 326 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 327 18 327 88] Seq.(==) (Seq.(++) (Seq.singleton result) (Model0.model ( ^ self))) (Model0.model ( * self)) }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 328 39 328 40] Inv1.inv result }
    
end
module CargoDir_LinkedList_Impl0_PopFront
  type t
  use prelude.Borrow
  use prelude.Ghost
  use seq.Seq
  use prelude.Int
  use prelude.Opaque
  use seq_ext.SeqExt
  use map.Map
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial13 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv13.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial12 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv12.inv,
    axiom .
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial11 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv11.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial10 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Util_Unwrap_Interface as Unwrap0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv13.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = opaque_ptr
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = opaque_ptr,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = t
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = t,
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  use seq.Seq
  use prelude.Ghost
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = borrowed (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = borrowed (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Util_Impl0_MakeSized_Interface as MakeSized0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv12.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Interface as Len0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv10.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv10.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv11.inv
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  clone CreusotContracts_Logic_Fmap_Impl0_Insert_Interface as Insert0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv7.inv,
    predicate Inv2.inv = Inv12.inv,
    function View0.view = View0.view,
    function MakeSized0.make_sized = MakeSized0.make_sized,
    function Contains0.contains = Contains0.contains,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv3.inv = Inv11.inv,
    predicate Inv4.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel1 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    type ShallowModelTy0.shallowModelTy = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_NextOf as NextOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_PrevOf as PrevOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized as LookupUnsized0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get,
    function Unwrap0.unwrap = Unwrap0.unwrap,
    predicate Inv0.inv = Inv13.inv,
    predicate Inv1.inv = Inv4.inv
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized
  clone CreusotContracts_Logic_Fmap_Impl0_Remove_Interface as Remove0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv7.inv,
    function View0.view = View0.view,
    function Len0.len = Len0.len,
    function Contains0.contains = Contains0.contains,
    function Mk0.mk = Mk0.mk,
    predicate Inv2.inv = Inv11.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CargoDir_LinkedList_Impl0_WfToken as WfToken0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Contains0.contains = Contains0.contains,
    function Lookup0.lookup = Lookup0.lookup,
    function PrevOf0.prev_of = PrevOf0.prev_of,
    function NextOf0.next_of = NextOf0.next_of,
    axiom .
  clone CargoDir_LinkedList_Impl0_Invariant as Invariant0 with
    type t = t,
    predicate WfToken0.wf_token = WfToken0.wf_token,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve6 with
    type self = CargoDir_LinkedList_Node_Type.t_node t
  clone CargoDir_LinkedList_Impl0_Model as Model0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Lookup0.lookup = Lookup0.lookup
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve5 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = Ghost.ghost_ty (Seq.seq opaque_ptr)
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve3 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = opaque_ptr
  clone Core_Ptr_Null_Interface as Null0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_GhostPtr_Impl1_PtrAsMut_Interface as PtrAsMut0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function Contains0.contains = Contains0.contains,
    predicate Inv0.inv = Inv9.inv,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized,
    function Insert0.insert = Insert0.insert,
    predicate Inv1.inv = Inv2.inv,
    predicate Inv2.inv = Inv10.inv,
    predicate Inv3.inv = Inv7.inv,
    predicate Inv4.inv = Inv12.inv,
    function View0.view = View0.view,
    function MakeSized0.make_sized = MakeSized0.make_sized,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv5.inv = Inv11.inv,
    predicate Inv6.inv = Inv4.inv
  clone CreusotContracts_Logic_Fmap_Impl0_Subset as Subset0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv7.inv,
    function Contains0.contains = Contains0.contains,
    function Get0.get = Get0.get
  clone CreusotContracts_GhostPtr_Impl1_PtrToBox_Interface as PtrToBox0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    predicate Inv0.inv = Inv9.inv,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized,
    function Remove0.remove = Remove0.remove,
    predicate Inv1.inv = Inv4.inv,
    predicate Inv2.inv = Inv10.inv,
    predicate Inv3.inv = Inv7.inv,
    function View0.view = View0.view,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv4.inv = Inv11.inv
  clone Core_Ptr_ConstPtr_Impl0_IsNull_Interface as IsNull0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = ()
  clone CargoDir_Lemmas_MapSetCommute_Interface as MapSetCommute0 with
    type k = opaque_ptr,
    type v = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv7.inv,
    predicate Inv2.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  let rec cfg pop_front [#"/root/milli/creusot/cargo-dir/src/lib.rs" 328 8 328 40] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)) : t
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 324 19 324 38] Invariant0.invariant' ( * self)}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 325 19 325 44] Seq.length (Model0.model ( * self)) > 0}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 328 30 328 34] Inv3.inv self}
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 326 18 326 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 327 18 327 88] Seq.(==) (Seq.(++) (Seq.singleton result) (Model0.model ( ^ self))) (Model0.model ( * self)) }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 328 39 328 40] Inv5.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : t;
  var self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) = self;
  var self_ghost_old : Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
  var _8 : ();
  var _9 : bool;
  var node : CargoDir_LinkedList_Node_Type.t_node t;
  var _20 : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
  var _27 : ();
  var _28 : bool;
  var _30 : opaque_ptr;
  var _31 : Ghost.ghost_ty (Seq.seq opaque_ptr);
  var new_head : borrowed (CargoDir_LinkedList_Node_Type.t_node t);
  var _44 : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
  var _46 : opaque_ptr;
  var _47 : Ghost.ghost_ty (Seq.seq opaque_ptr);
  {
    goto BB0
  }
  BB0 {
    self_ghost_old <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 329 33 329 43] Ghost.new ( * self));
    goto BB1
  }
  BB1 {
    assert { [@expl:type invariant] Inv0.inv self_ghost_old };
    assume { Resolve0.resolve self_ghost_old };
    _8 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 330 12 330 62] ());
    assume { Resolve1.resolve _8 };
    _9 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 331 15 331 34] IsNull0.is_null (CargoDir_LinkedList_LinkedList_Type.linkedlist_head ( * self)));
    goto BB2
  }
  BB2 {
    switch (_9)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [@expl:type invariant] Inv3.inv self };
    assume { Resolve5.resolve self };
    absurd
  }
  BB4 {
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 334 30 334 55] CargoDir_LinkedList_LinkedList_Type.linkedlist_head ( * self) = IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) 0 };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 335 30 335 49] Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) > 0 };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 336 16 336 80] Contains0.contains (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) 0) };
    _20 <- Borrow.borrow_mut (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self));
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c ( ^ _20)) };
    assume { Inv1.inv ( ^ _20) };
    node <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 337 27 337 59] PtrToBox0.ptr_to_box _20 (CargoDir_LinkedList_LinkedList_Type.linkedlist_head ( * self)));
    _20 <- any borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
    goto BB5
  }
  BB5 {
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 338 16 338 158] forall i : opaque_ptr . Contains0.contains (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token (Ghost.inner self_ghost_old))) i /\ i <> IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) 0 -> Contains0.contains (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) i };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 339 16 339 131] forall i : int . 1 <= i /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) -> Contains0.contains (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) i) };
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList (CargoDir_LinkedList_Node_Type.node_next node) b c d) };
    _28 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 341 19 341 38] IsNull0.is_null (CargoDir_LinkedList_LinkedList_Type.linkedlist_head ( * self)));
    goto BB6
  }
  BB6 {
    switch (_28)
      | False -> goto BB10
      | True -> goto BB7
      end
  }
  BB7 {
    _30 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 342 32 342 43] Null0.null ());
    goto BB8
  }
  BB8 {
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a _30 c d) };
    _30 <- any opaque_ptr;
    _31 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 343 32 343 78] Ghost.new (SeqExt.subsequence (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) 1 (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))))));
    goto BB9
  }
  BB9 {
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b _31 d) };
    _31 <- any Ghost.ghost_ty (Seq.seq opaque_ptr);
    assume { Resolve4.resolve (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) };
    assert { [@expl:type invariant] Inv3.inv self };
    assume { Resolve5.resolve self };
    _27 <- ();
    goto BB14
  }
  BB10 {
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 345 34 345 53] Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) > 1 };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 346 20 346 106] Subset0.subset (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token (Ghost.inner self_ghost_old))) };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 347 34 347 50] WfToken0.wf_token ( * self) 1 };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 348 20 348 84] Contains0.contains (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) 1) };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 349 34 349 59] CargoDir_LinkedList_LinkedList_Type.linkedlist_head ( * self) = IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) 1 };
    _44 <- Borrow.borrow_mut (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self));
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c ( ^ _44)) };
    assume { Inv1.inv ( ^ _44) };
    new_head <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 350 35 350 67] PtrAsMut0.ptr_as_mut _44 (CargoDir_LinkedList_LinkedList_Type.linkedlist_head ( * self)));
    _44 <- any borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
    goto BB11
  }
  BB11 {
    _46 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 351 36 351 47] Null0.null ());
    goto BB12
  }
  BB12 {
    new_head <- { new_head with current = (let CargoDir_LinkedList_Node_Type.C_Node a b c =  * new_head in CargoDir_LinkedList_Node_Type.C_Node a b _46) };
    _46 <- any opaque_ptr;
    assume { Resolve2.resolve (CargoDir_LinkedList_Node_Type.node_prev ( * new_head)) };
    assert { [@expl:type invariant] Inv2.inv new_head };
    assume { Resolve3.resolve new_head };
    _47 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 352 32 352 78] Ghost.new (SeqExt.subsequence (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) 1 (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))))));
    goto BB13
  }
  BB13 {
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b _47 d) };
    _47 <- any Ghost.ghost_ty (Seq.seq opaque_ptr);
    assume { Resolve4.resolve (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) };
    assert { [@expl:type invariant] Inv3.inv self };
    assume { Resolve5.resolve self };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 353 20 353 136] forall i : int . 0 <= i /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) /\ WfToken0.wf_token (Ghost.inner self_ghost_old) (i + 1) -> WfToken0.wf_token ( * self) i };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 354 20 354 102] forall i : int . 1 <= i /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) -> WfToken0.wf_token ( * self) i };
    _27 <- ();
    goto BB14
  }
  BB14 {
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 357 30 357 68] CargoDir_LinkedList_Node_Type.node_data node = Seq.get (Model0.model (Ghost.inner self_ghost_old)) 0 };
    goto BB15
  }
  BB15 {
    _0 <- CargoDir_LinkedList_Node_Type.node_data node;
    node <- (let CargoDir_LinkedList_Node_Type.C_Node a b c = node in CargoDir_LinkedList_Node_Type.C_Node (any t) b c);
    assert { [@expl:type invariant] Inv4.inv node };
    assume { Resolve6.resolve node };
    goto BB16
  }
  BB16 {
    return _0
  }
  
end
module CargoDir_LinkedList_Impl0_PopBack_Interface
  type t
  use prelude.Borrow
  use seq.Seq
  use prelude.Int
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone CargoDir_LinkedList_Impl0_Model_Stub as Model0 with
    type t = t
  clone CargoDir_LinkedList_Impl0_Invariant_Stub as Invariant0 with
    type t = t
  val pop_back [#"/root/milli/creusot/cargo-dir/src/lib.rs" 366 8 366 39] (self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)) : t
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 362 19 362 38] Invariant0.invariant' ( * self)}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 363 19 363 44] Seq.length (Model0.model ( * self)) > 0}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 366 29 366 33] Inv0.inv self}
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 364 18 364 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 365 18 365 88] Seq.(==) (Seq.(++) (Model0.model ( ^ self)) (Seq.singleton result)) (Model0.model ( * self)) }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 366 38 366 39] Inv1.inv result }
    
end
module CargoDir_LinkedList_Impl0_PopBack
  type t
  use prelude.Borrow
  use prelude.Ghost
  use prelude.Opaque
  use seq.Seq
  use prelude.Int
  use seq_ext.SeqExt
  use map.Map
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv13 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial13 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv13.inv,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial12 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv12.inv,
    axiom .
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial11 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv11.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial10 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Util_Unwrap_Interface as Unwrap0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv13.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = opaque_ptr
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = opaque_ptr,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = t
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = t,
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv4.inv,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  use seq.Seq
  use prelude.Ghost
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = borrowed (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = borrowed (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Util_Impl0_MakeSized_Interface as MakeSized0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv12.inv,
    predicate Inv1.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Interface as Len0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv10.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv10.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv11.inv
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  clone CreusotContracts_Logic_Fmap_Impl0_Insert_Interface as Insert0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv7.inv,
    predicate Inv2.inv = Inv12.inv,
    function View0.view = View0.view,
    function MakeSized0.make_sized = MakeSized0.make_sized,
    function Contains0.contains = Contains0.contains,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv3.inv = Inv11.inv,
    predicate Inv4.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel1 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    type ShallowModelTy0.shallowModelTy = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_NextOf as NextOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_PrevOf as PrevOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized as LookupUnsized0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get,
    function Unwrap0.unwrap = Unwrap0.unwrap,
    predicate Inv0.inv = Inv13.inv,
    predicate Inv1.inv = Inv4.inv
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized
  clone CreusotContracts_Logic_Fmap_Impl0_Remove_Interface as Remove0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv10.inv,
    predicate Inv1.inv = Inv7.inv,
    function View0.view = View0.view,
    function Len0.len = Len0.len,
    function Contains0.contains = Contains0.contains,
    function Mk0.mk = Mk0.mk,
    predicate Inv2.inv = Inv11.inv,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CargoDir_LinkedList_Impl0_Model as Model0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Lookup0.lookup = Lookup0.lookup
  clone CargoDir_LinkedList_Impl0_WfToken as WfToken0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Contains0.contains = Contains0.contains,
    function Lookup0.lookup = Lookup0.lookup,
    function PrevOf0.prev_of = PrevOf0.prev_of,
    function NextOf0.next_of = NextOf0.next_of,
    axiom .
  clone CargoDir_LinkedList_Impl0_Invariant as Invariant0 with
    type t = t,
    predicate WfToken0.wf_token = WfToken0.wf_token,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve6 with
    type self = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve5 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = Ghost.ghost_ty (Seq.seq opaque_ptr)
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve3 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = opaque_ptr
  clone Core_Ptr_Null_Interface as Null0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_GhostPtr_Impl1_PtrAsMut_Interface as PtrAsMut0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function Contains0.contains = Contains0.contains,
    predicate Inv0.inv = Inv9.inv,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized,
    function Insert0.insert = Insert0.insert,
    predicate Inv1.inv = Inv2.inv,
    predicate Inv2.inv = Inv10.inv,
    predicate Inv3.inv = Inv7.inv,
    predicate Inv4.inv = Inv12.inv,
    function View0.view = View0.view,
    function MakeSized0.make_sized = MakeSized0.make_sized,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv5.inv = Inv11.inv,
    predicate Inv6.inv = Inv4.inv
  clone CreusotContracts_Logic_Fmap_Impl0_Subset as Subset0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv7.inv,
    function Contains0.contains = Contains0.contains,
    function Get0.get = Get0.get
  clone CreusotContracts_GhostPtr_Impl1_PtrToBox_Interface as PtrToBox0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    predicate Inv0.inv = Inv9.inv,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized,
    function Remove0.remove = Remove0.remove,
    predicate Inv1.inv = Inv4.inv,
    predicate Inv2.inv = Inv10.inv,
    predicate Inv3.inv = Inv7.inv,
    function View0.view = View0.view,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv4.inv = Inv11.inv
  clone Core_Ptr_ConstPtr_Impl0_IsNull_Interface as IsNull0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    predicate Inv0.inv = Inv1.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = ()
  clone CargoDir_Lemmas_MapSetCommute_Interface as MapSetCommute0 with
    type k = opaque_ptr,
    type v = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv7.inv,
    predicate Inv2.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  let rec cfg pop_back [#"/root/milli/creusot/cargo-dir/src/lib.rs" 366 8 366 39] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)) : t
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 362 19 362 38] Invariant0.invariant' ( * self)}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 363 19 363 44] Seq.length (Model0.model ( * self)) > 0}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 366 29 366 33] Inv3.inv self}
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 364 18 364 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 365 18 365 88] Seq.(==) (Seq.(++) (Model0.model ( ^ self)) (Seq.singleton result)) (Model0.model ( * self)) }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 366 38 366 39] Inv5.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : t;
  var self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) = self;
  var self_ghost_old : Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
  var _8 : ();
  var _9 : bool;
  var node : CargoDir_LinkedList_Node_Type.t_node t;
  var _14 : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
  var _21 : ();
  var _22 : bool;
  var _24 : opaque_ptr;
  var new_tail : borrowed (CargoDir_LinkedList_Node_Type.t_node t);
  var _36 : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
  var _38 : opaque_ptr;
  var _39 : Ghost.ghost_ty (Seq.seq opaque_ptr);
  {
    goto BB0
  }
  BB0 {
    self_ghost_old <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 367 33 367 43] Ghost.new ( * self));
    goto BB1
  }
  BB1 {
    assert { [@expl:type invariant] Inv0.inv self_ghost_old };
    assume { Resolve0.resolve self_ghost_old };
    _8 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 368 12 368 62] ());
    assume { Resolve1.resolve _8 };
    _9 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 369 15 369 34] IsNull0.is_null (CargoDir_LinkedList_LinkedList_Type.linkedlist_tail ( * self)));
    goto BB2
  }
  BB2 {
    switch (_9)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assert { [@expl:type invariant] Inv3.inv self };
    assume { Resolve5.resolve self };
    absurd
  }
  BB4 {
    _14 <- Borrow.borrow_mut (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self));
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c ( ^ _14)) };
    assume { Inv1.inv ( ^ _14) };
    node <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 372 27 372 59] PtrToBox0.ptr_to_box _14 (CargoDir_LinkedList_LinkedList_Type.linkedlist_tail ( * self)));
    _14 <- any borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
    goto BB5
  }
  BB5 {
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 373 16 373 176] forall i : opaque_ptr . Contains0.contains (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token (Ghost.inner self_ghost_old))) i /\ i <> IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) - 1) -> Contains0.contains (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) i };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 374 16 374 135] forall i : int . 0 <= i /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) - 1 -> Contains0.contains (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) i) };
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a (CargoDir_LinkedList_Node_Type.node_prev node) c d) };
    _22 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 376 19 376 38] IsNull0.is_null (CargoDir_LinkedList_LinkedList_Type.linkedlist_tail ( * self)));
    goto BB6
  }
  BB6 {
    switch (_22)
      | False -> goto BB9
      | True -> goto BB7
      end
  }
  BB7 {
    _24 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 377 32 377 43] Null0.null ());
    goto BB8
  }
  BB8 {
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList _24 b c d) };
    _24 <- any opaque_ptr;
    _21 <- ();
    goto BB12
  }
  BB9 {
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 379 34 379 53] Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) > 1 };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 380 20 380 106] Subset0.subset (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token (Ghost.inner self_ghost_old))) };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 381 34 381 68] WfToken0.wf_token ( * self) (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) - 2) };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 382 20 382 102] Contains0.contains (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) - 2)) };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 383 34 383 77] CargoDir_LinkedList_LinkedList_Type.linkedlist_tail ( * self) = IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) - 2) };
    _36 <- Borrow.borrow_mut (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self));
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c ( ^ _36)) };
    assume { Inv1.inv ( ^ _36) };
    new_tail <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 384 35 384 67] PtrAsMut0.ptr_as_mut _36 (CargoDir_LinkedList_LinkedList_Type.linkedlist_tail ( * self)));
    _36 <- any borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
    goto BB10
  }
  BB10 {
    _38 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 385 36 385 47] Null0.null ());
    goto BB11
  }
  BB11 {
    new_tail <- { new_tail with current = (let CargoDir_LinkedList_Node_Type.C_Node a b c =  * new_tail in CargoDir_LinkedList_Node_Type.C_Node a _38 c) };
    _38 <- any opaque_ptr;
    assume { Resolve2.resolve (CargoDir_LinkedList_Node_Type.node_next ( * new_tail)) };
    assert { [@expl:type invariant] Inv2.inv new_tail };
    assume { Resolve3.resolve new_tail };
    _21 <- ();
    goto BB12
  }
  BB12 {
    _39 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 387 28 387 78] Ghost.new (SeqExt.subsequence (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) 0 (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) - 1)));
    goto BB13
  }
  BB13 {
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b _39 d) };
    _39 <- any Ghost.ghost_ty (Seq.seq opaque_ptr);
    assume { Resolve4.resolve (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) };
    assert { [@expl:type invariant] Inv3.inv self };
    assume { Resolve5.resolve self };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 388 16 388 129] forall i : int . 0 <= i /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) -> WfToken0.wf_token (Ghost.inner self_ghost_old) i -> WfToken0.wf_token ( * self) i };
    _0 <- CargoDir_LinkedList_Node_Type.node_data node;
    node <- (let CargoDir_LinkedList_Node_Type.C_Node a b c = node in CargoDir_LinkedList_Node_Type.C_Node (any t) b c);
    assert { [@expl:type invariant] Inv4.inv node };
    assume { Resolve6.resolve node };
    goto BB14
  }
  BB14 {
    return _0
  }
  
end
module CreusotContracts_Logic_Fmap_Impl0_Disjoint_Stub
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function disjoint (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : bool
    
end
module CreusotContracts_Logic_Fmap_Impl0_Disjoint_Interface
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  function disjoint (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : bool
    
  val disjoint (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : bool
    ensures { result = disjoint self other }
    
end
module CreusotContracts_Logic_Fmap_Impl0_Disjoint
  type k
  type v
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = k
  function disjoint (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : bool
    
   =
    [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 98 8 98 72] forall k : k . Inv0.inv k -> not Contains0.contains self k \/ not Contains0.contains other k
  val disjoint (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : bool
    ensures { result = disjoint self other }
    
end
module CreusotContracts_Logic_Fmap_Impl0_Union_Stub
  type k
  type v
  use prelude.Int
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = k,
    type v = v
  clone CreusotContracts_Logic_Fmap_Impl0_Get_Stub as Get0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Logic_Fmap_Impl0_Disjoint_Stub as Disjoint0 with
    type k = k,
    type v = v
  function union (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    
end
module CreusotContracts_Logic_Fmap_Impl0_Union_Interface
  type k
  type v
  use prelude.Int
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = k,
    type v = v
  clone CreusotContracts_Logic_Fmap_Impl0_Get_Stub as Get0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Logic_Fmap_Impl0_Disjoint_Stub as Disjoint0 with
    type k = k,
    type v = v
  function union (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    
  val union (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    requires {[#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 110 15 110 35] Disjoint0.disjoint self other}
    requires {[#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 119 17 119 21] Inv0.inv self}
    requires {[#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 119 23 119 28] Inv0.inv other}
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 111 4 117 7] forall k : k . Inv1.inv k -> Get0.get result k = (if Contains0.contains self k then
      Get0.get self k
    else
      if Contains0.contains other k then Get0.get other k else Core_Option_Option_Type.C_None
    ) }
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 118 14 118 54] Len0.len result = Len0.len self + Len0.len other }
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 119 4 119 43] Inv0.inv result }
    ensures { result = union self other }
    
  axiom union_spec : forall self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v, other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v . ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 110 15 110 35] Disjoint0.disjoint self other) -> ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 119 17 119 21] Inv0.inv self) -> ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 119 23 119 28] Inv0.inv other) -> ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 119 4 119 43] Inv0.inv (union self other)) && ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 118 14 118 54] Len0.len (union self other) = Len0.len self + Len0.len other) && ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 111 4 117 7] forall k : k . Inv1.inv k -> Get0.get (union self other) k = (if Contains0.contains self k then
    Get0.get self k
  else
    if Contains0.contains other k then Get0.get other k else Core_Option_Option_Type.C_None
  ))
end
module CreusotContracts_Logic_Fmap_Impl0_Union
  type k
  type v
  use prelude.Int
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = k,
    type v = v,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = k,
    type v = v
  clone CreusotContracts_Logic_Fmap_Impl0_Get_Stub as Get0 with
    type k = k,
    type v = v
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = k
  clone CreusotContracts_Logic_Fmap_Impl0_Disjoint_Stub as Disjoint0 with
    type k = k,
    type v = v
  function union (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    
  val union (self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) (other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v) : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v
    requires {[#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 110 15 110 35] Disjoint0.disjoint self other}
    requires {[#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 119 17 119 21] Inv0.inv self}
    requires {[#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 119 23 119 28] Inv0.inv other}
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 111 4 117 7] forall k : k . Inv1.inv k -> Get0.get result k = (if Contains0.contains self k then
      Get0.get self k
    else
      if Contains0.contains other k then Get0.get other k else Core_Option_Option_Type.C_None
    ) }
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 118 14 118 54] Len0.len result = Len0.len self + Len0.len other }
    ensures { [#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 119 4 119 43] Inv0.inv result }
    ensures { result = union self other }
    
  axiom union_spec : forall self : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v, other : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap k v . ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 110 15 110 35] Disjoint0.disjoint self other) -> ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 119 17 119 21] Inv0.inv self) -> ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 119 23 119 28] Inv0.inv other) -> ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 119 4 119 43] Inv0.inv (union self other)) && ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 118 14 118 54] Len0.len (union self other) = Len0.len self + Len0.len other) && ([#"/root/creusot/creusot-contracts/src/logic/fmap.rs" 111 4 117 7] forall k : k . Inv1.inv k -> Get0.get (union self other) k = (if Contains0.contains self k then
    Get0.get self k
  else
    if Contains0.contains other k then Get0.get other k else Core_Option_Option_Type.C_None
  ))
end
module CreusotContracts_GhostPtr_Impl1_Merge_Interface
  type t
  use prelude.Borrow
  use prelude.Opaque
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv2 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Stub as Len0 with
    type k = opaque_ptr,
    type v = t,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Logic_Fmap_Impl0_Get_Stub as Get0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv3 with
    type t = opaque_ptr
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Logic_Fmap_Impl0_Disjoint_Stub as Disjoint0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Logic_Fmap_Impl0_Union_Stub as Union0 with
    type k = opaque_ptr,
    type v = t,
    function Disjoint0.disjoint = Disjoint0.disjoint,
    predicate Inv0.inv = Inv2.inv,
    predicate Inv1.inv = Inv3.inv,
    function Get0.get = Get0.get,
    function Contains0.contains = Contains0.contains,
    function Len0.len = Len0.len,
    axiom .
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t)
  val merge (self : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t)) (_other : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t) : ()
    requires {[#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 118 22 118 26] Inv0.inv self}
    requires {[#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 118 28 118 34] Inv1.inv _other}
    ensures { [#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 114 4 114 42] Disjoint0.disjoint (ShallowModel0.shallow_model ( * self)) (ShallowModel0.shallow_model _other) }
    ensures { [#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 117 14 117 49] ShallowModel0.shallow_model ( ^ self) = Union0.union (ShallowModel0.shallow_model ( * self)) (ShallowModel0.shallow_model _other) }
    
end
module CargoDir_LinkedList_Impl0_Append_Interface
  type t
  use prelude.Borrow
  use seq.Seq
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_Model_Stub as Model0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone CargoDir_LinkedList_Impl0_Invariant_Stub as Invariant0 with
    type t = t
  val append [#"/root/milli/creusot/cargo-dir/src/lib.rs" 397 8 397 49] (self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)) (other : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) : ()
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 393 19 393 38] Invariant0.invariant' ( * self)}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 394 19 394 36] Invariant0.invariant' other}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 397 27 397 31] Inv0.inv self}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 397 37 397 42] Inv1.inv other}
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 395 18 395 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 396 18 396 79] Seq.(==) (Model0.model ( ^ self)) (Seq.(++) (Model0.model ( * self)) (Model0.model other)) }
    
end
module CargoDir_LinkedList_Impl0_Append
  type t
  use prelude.Ghost
  use prelude.Borrow
  use seq.Seq
  use prelude.Opaque
  use prelude.Int
  use map.Map
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial12 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial11 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv11.inv,
    axiom .
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial10 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = opaque_ptr
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = opaque_ptr,
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Util_Unwrap_Interface as Unwrap0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv12.inv,
    predicate Inv1.inv = Inv11.inv,
    axiom .
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv7.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv6.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv6.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv10.inv
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv4.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_NextOf as NextOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv4.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_PrevOf as PrevOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv4.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  use seq.Seq
  use prelude.Ghost
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = borrowed (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = borrowed (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Len_Interface as Len0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Util_Impl0_MakeSized_Interface as MakeSized0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Insert_Interface as Insert0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv8.inv,
    predicate Inv2.inv = Inv9.inv,
    function View0.view = View0.view,
    function MakeSized0.make_sized = MakeSized0.make_sized,
    function Contains0.contains = Contains0.contains,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv3.inv = Inv10.inv,
    predicate Inv4.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized as LookupUnsized0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get,
    function Unwrap0.unwrap = Unwrap0.unwrap,
    predicate Inv0.inv = Inv12.inv,
    predicate Inv1.inv = Inv11.inv
  clone CreusotContracts_Model_Impl7_ShallowModel as ShallowModel1 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    type ShallowModelTy0.shallowModelTy = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = Ghost.ghost_ty (borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t))
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = Ghost.ghost_ty (borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized
  clone CargoDir_LinkedList_Impl0_Model as Model0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Lookup0.lookup = Lookup0.lookup
  clone CargoDir_LinkedList_Impl0_WfToken as WfToken0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Contains0.contains = Contains0.contains,
    function Lookup0.lookup = Lookup0.lookup,
    function PrevOf0.prev_of = PrevOf0.prev_of,
    function NextOf0.next_of = NextOf0.next_of,
    axiom .
  clone CargoDir_LinkedList_Impl0_Invariant as Invariant0 with
    type t = t,
    predicate WfToken0.wf_token = WfToken0.wf_token,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv4.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Logic_Fmap_Impl0_Subset as Subset0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv8.inv,
    function Contains0.contains = Contains0.contains,
    function Get0.get = Get0.get
  clone CreusotContracts_Logic_Fmap_Impl0_Disjoint as Disjoint0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv8.inv,
    function Contains0.contains = Contains0.contains
  clone CreusotContracts_Logic_Fmap_Impl0_Union_Interface as Union0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Disjoint0.disjoint = Disjoint0.disjoint,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv8.inv,
    function Get0.get = Get0.get,
    function Contains0.contains = Contains0.contains,
    function Len0.len = Len0.len,
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve6 with
    type self = Ghost.ghost_ty (Seq.seq opaque_ptr)
  clone CreusotContracts_GhostPtr_Impl1_Merge_Interface as Merge0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv7.inv,
    predicate Inv1.inv = Inv4.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Disjoint0.disjoint = Disjoint0.disjoint,
    function Union0.union = Union0.union,
    predicate Inv2.inv = Inv6.inv,
    predicate Inv3.inv = Inv8.inv,
    function Get0.get = Get0.get,
    function Contains0.contains = Contains0.contains,
    function Len0.len = Len0.len
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve5 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl1_PtrAsMut_Interface as PtrAsMut0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function Contains0.contains = Contains0.contains,
    predicate Inv0.inv = Inv7.inv,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized,
    function Insert0.insert = Insert0.insert,
    predicate Inv1.inv = Inv5.inv,
    predicate Inv2.inv = Inv6.inv,
    predicate Inv3.inv = Inv8.inv,
    predicate Inv4.inv = Inv9.inv,
    function View0.view = View0.view,
    function MakeSized0.make_sized = MakeSized0.make_sized,
    function Len0.len = Len0.len,
    function Mk0.mk = Mk0.mk,
    predicate Inv5.inv = Inv10.inv,
    predicate Inv6.inv = Inv11.inv
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve3 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone Core_Ptr_ConstPtr_Impl0_IsNull_Interface as IsNull0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    predicate Inv0.inv = Inv4.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Ghost.ghost_ty (borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t))
  let rec cfg append [#"/root/milli/creusot/cargo-dir/src/lib.rs" 397 8 397 49] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)) (other : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) : ()
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 393 19 393 38] Invariant0.invariant' ( * self)}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 394 19 394 36] Invariant0.invariant' other}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 397 27 397 31] Inv3.inv self}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 397 37 397 42] Inv2.inv other}
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 395 18 395 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 396 18 396 79] Seq.(==) (Model0.model ( ^ self)) (Seq.(++) (Model0.model ( * self)) (Model0.model other)) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) = self;
  var other : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t = other;
  var old_self : Ghost.ghost_ty (borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t));
  var old_other : Ghost.ghost_ty (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
  var _11 : bool;
  var _15 : bool;
  var tail : borrowed (CargoDir_LinkedList_Node_Type.t_node t);
  var _18 : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
  var head : borrowed (CargoDir_LinkedList_Node_Type.t_node t);
  var _22 : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
  var _25 : ();
  var _26 : borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
  var _29 : Ghost.ghost_ty (Seq.seq opaque_ptr);
  {
    goto BB0
  }
  BB0 {
    old_self <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 398 27 398 36] Ghost.new self);
    goto BB1
  }
  BB1 {
    assert { [@expl:type invariant] Inv0.inv old_self };
    assume { Resolve0.resolve old_self };
    old_other <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 399 28 399 38] Ghost.new other);
    goto BB2
  }
  BB2 {
    assert { [@expl:type invariant] Inv1.inv old_other };
    assume { Resolve1.resolve old_other };
    _11 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 400 15 400 34] IsNull0.is_null (CargoDir_LinkedList_LinkedList_Type.linkedlist_head ( * self)));
    goto BB3
  }
  BB3 {
    switch (_11)
      | False -> goto BB5
      | True -> goto BB4
      end
  }
  BB4 {
    self <- { self with current = other };
    other <- any CargoDir_LinkedList_LinkedList_Type.t_linkedlist t;
    assert { [@expl:type invariant] Inv2.inv ( * self) };
    assume { Resolve2.resolve ( * self) };
    assert { [@expl:type invariant] Inv3.inv self };
    assume { Resolve3.resolve self };
    _0 <- ();
    goto BB14
  }
  BB5 {
    _15 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 402 23 402 43] IsNull0.is_null (CargoDir_LinkedList_LinkedList_Type.linkedlist_head other));
    goto BB6
  }
  BB6 {
    switch (not _15)
      | False -> goto BB12
      | True -> goto BB7
      end
  }
  BB7 {
    _18 <- Borrow.borrow_mut (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self));
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c ( ^ _18)) };
    assume { Inv4.inv ( ^ _18) };
    tail <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 403 27 403 59] PtrAsMut0.ptr_as_mut _18 (CargoDir_LinkedList_LinkedList_Type.linkedlist_tail ( * self)));
    _18 <- any borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
    goto BB8
  }
  BB8 {
    tail <- { tail with current = (let CargoDir_LinkedList_Node_Type.C_Node a b c =  * tail in CargoDir_LinkedList_Node_Type.C_Node a (CargoDir_LinkedList_LinkedList_Type.linkedlist_head other) c) };
    assume { Resolve4.resolve (CargoDir_LinkedList_Node_Type.node_next ( * tail)) };
    assert { [@expl:type invariant] Inv5.inv tail };
    assume { Resolve5.resolve tail };
    _22 <- Borrow.borrow_mut (CargoDir_LinkedList_LinkedList_Type.linkedlist_token other);
    other <- (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d = other in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c ( ^ _22));
    assume { Inv4.inv ( ^ _22) };
    head <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 405 27 405 61] PtrAsMut0.ptr_as_mut _22 (CargoDir_LinkedList_LinkedList_Type.linkedlist_head other));
    _22 <- any borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
    goto BB9
  }
  BB9 {
    head <- { head with current = (let CargoDir_LinkedList_Node_Type.C_Node a b c =  * head in CargoDir_LinkedList_Node_Type.C_Node a b (CargoDir_LinkedList_LinkedList_Type.linkedlist_tail ( * self))) };
    assume { Resolve4.resolve (CargoDir_LinkedList_Node_Type.node_prev ( * head)) };
    assert { [@expl:type invariant] Inv5.inv head };
    assume { Resolve5.resolve head };
    _26 <- Borrow.borrow_mut (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self));
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c ( ^ _26)) };
    assume { Inv4.inv ( ^ _26) };
    _25 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 408 16 408 45] Merge0.merge _26 (CargoDir_LinkedList_LinkedList_Type.linkedlist_token other));
    _26 <- any borrowed (CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t));
    other <- (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d = other in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c (any CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)));
    goto BB10
  }
  BB10 {
    assert { [@expl:type invariant] Inv2.inv other };
    assume { Resolve2.resolve other };
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a (CargoDir_LinkedList_LinkedList_Type.linkedlist_tail other) c d) };
    _29 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 410 28 410 62] Ghost.new (Seq.(++) (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self))) (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs other))));
    goto BB11
  }
  BB11 {
    self <- { self with current = (let CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b c d =  * self in CargoDir_LinkedList_LinkedList_Type.C_LinkedList a b _29 d) };
    _29 <- any Ghost.ghost_ty (Seq.seq opaque_ptr);
    assume { Resolve6.resolve (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * self)) };
    assert { [@expl:type invariant] Inv3.inv self };
    assume { Resolve3.resolve self };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 411 16 411 116] forall b : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t) . forall a : CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t) . Inv6.inv b -> Inv6.inv a -> Disjoint0.disjoint a b -> Subset0.subset a (Union0.union a b) };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 413 16 415 72] forall i : int . 0 <= i /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * Ghost.inner old_self))) - 1 -> Lookup0.lookup (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * Ghost.inner old_self))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * Ghost.inner old_self)) i) = Lookup0.lookup (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * Ghost.inner old_self)) i) };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 416 16 418 73] forall i : int . 1 <= i /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs (Ghost.inner old_other))) -> Lookup0.lookup (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token (Ghost.inner old_other))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs (Ghost.inner old_other)) i) = Lookup0.lookup (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs (Ghost.inner old_other)) i) };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 419 30 420 102] CargoDir_LinkedList_Node_Type.node_prev (Lookup0.lookup (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * Ghost.inner old_self)) (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * Ghost.inner old_self))) - 1))) = CargoDir_LinkedList_Node_Type.node_prev (Lookup0.lookup (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * Ghost.inner old_self))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * Ghost.inner old_self)) (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * Ghost.inner old_self))) - 1))) };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 421 30 422 82] CargoDir_LinkedList_Node_Type.node_next (Lookup0.lookup (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token ( * self))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs (Ghost.inner old_other)) 0)) = CargoDir_LinkedList_Node_Type.node_next (Lookup0.lookup (ShallowModel0.shallow_model (CargoDir_LinkedList_LinkedList_Type.linkedlist_token (Ghost.inner old_other))) (IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs (Ghost.inner old_other)) 0)) };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 423 30 423 68] WfToken0.wf_token ( * self) (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * Ghost.inner old_self))) - 1) };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 424 30 424 64] WfToken0.wf_token ( * self) (Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * Ghost.inner old_self)))) };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 426 16 426 131] forall i : int . 0 <= i /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * Ghost.inner old_self))) - 1 -> WfToken0.wf_token ( * Ghost.inner old_self) i -> WfToken0.wf_token ( * self) i };
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 427 16 427 151] forall i : int . 1 <= i /\ i < Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs (Ghost.inner old_other))) -> WfToken0.wf_token (Ghost.inner old_other) i -> WfToken0.wf_token ( * self) (i + Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs ( * Ghost.inner old_self)))) };
    _0 <- ();
    goto BB13
  }
  BB12 {
    assert { [@expl:type invariant] Inv2.inv other };
    assume { Resolve2.resolve other };
    assert { [@expl:type invariant] Inv3.inv self };
    assume { Resolve3.resolve self };
    _0 <- ();
    goto BB13
  }
  BB13 {
    goto BB14
  }
  BB14 {
    return _0
  }
  
end
module CargoDir_LinkedList_Impl0_PushBack_Interface
  type t
  use prelude.Borrow
  use seq.Seq
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_Model_Stub as Model0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone CargoDir_LinkedList_Impl0_Invariant_Stub as Invariant0 with
    type t = t
  val push_back [#"/root/milli/creusot/cargo-dir/src/lib.rs" 434 8 434 43] (self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)) (val' : t) : ()
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 431 19 431 38] Invariant0.invariant' ( * self)}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 434 30 434 34] Inv0.inv self}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 434 36 434 39] Inv1.inv val'}
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 432 18 432 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 433 18 433 85] Seq.(==) (Model0.model ( ^ self)) (Seq.(++) (Model0.model ( * self)) (Seq.singleton val')) }
    
end
module CargoDir_LinkedList_Impl0_PushBack
  type t
  use prelude.Borrow
  use seq.Seq
  use map.Map
  use prelude.Opaque
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Util_Unwrap_Interface as Unwrap0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv4.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv4.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv5.inv
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized as LookupUnsized0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get,
    function Unwrap0.unwrap = Unwrap0.unwrap,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv7.inv
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_NextOf as NextOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_PrevOf as PrevOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = t
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = t,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CargoDir_LinkedList_Impl0_WfToken as WfToken0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Contains0.contains = Contains0.contains,
    function Lookup0.lookup = Lookup0.lookup,
    function PrevOf0.prev_of = PrevOf0.prev_of,
    function NextOf0.next_of = NextOf0.next_of,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CargoDir_LinkedList_Impl0_Model as Model0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Lookup0.lookup = Lookup0.lookup
  clone CargoDir_LinkedList_Impl0_Invariant as Invariant0 with
    type t = t,
    predicate WfToken0.wf_token = WfToken0.wf_token,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone CargoDir_LinkedList_Impl0_Append_Interface as Append0 with
    type t = t,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv0.inv,
    function Model0.model = Model0.model
  clone CargoDir_LinkedList_Impl0_Singleton_Interface as Singleton0 with
    type t = t,
    predicate Inv0.inv = Inv2.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    function Model0.model = Model0.model,
    predicate Inv1.inv = Inv0.inv
  let rec cfg push_back [#"/root/milli/creusot/cargo-dir/src/lib.rs" 434 8 434 43] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)) (val' : t) : ()
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 431 19 431 38] Invariant0.invariant' ( * self)}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 434 30 434 34] Inv1.inv self}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 434 36 434 39] Inv2.inv val'}
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 432 18 432 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 433 18 433 85] Seq.(==) (Model0.model ( ^ self)) (Seq.(++) (Model0.model ( * self)) (Seq.singleton val')) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) = self;
  var val' : t = val';
  var _6 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
  var _7 : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t;
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    _6 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _6) };
    assume { Inv0.inv ( ^ _6) };
    _7 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 435 24 435 44] Singleton0.singleton val');
    val' <- any t;
    goto BB2
  }
  BB2 {
    _0 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 435 12 435 45] Append0.append _6 _7);
    _6 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
    _7 <- any CargoDir_LinkedList_LinkedList_Type.t_linkedlist t;
    goto BB3
  }
  BB3 {
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve0.resolve self };
    goto BB4
  }
  BB4 {
    return _0
  }
  
end
module Core_Mem_Swap_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed t
  val swap (x : borrowed t) (y : borrowed t) : ()
    requires {[#"/rustc/5bd28f5eac1ba3569bfa8d49ec3f5acbdfdff7a0/library/core/src/mem/mod.rs" 726 21 726 22] Inv0.inv x}
    requires {[#"/rustc/5bd28f5eac1ba3569bfa8d49ec3f5acbdfdff7a0/library/core/src/mem/mod.rs" 726 32 726 33] Inv0.inv y}
    ensures { [#"/root/creusot/creusot-contracts/src/std/mem.rs" 11 22 11 30]  ^ x =  * y }
    ensures { [#"/root/creusot/creusot-contracts/src/std/mem.rs" 12 22 12 30]  ^ y =  * x }
    
end
module CargoDir_LinkedList_Impl0_PushFront_Interface
  type t
  use prelude.Borrow
  use seq.Seq
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_Model_Stub as Model0 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone CargoDir_LinkedList_Impl0_Invariant_Stub as Invariant0 with
    type t = t
  val push_front [#"/root/milli/creusot/cargo-dir/src/lib.rs" 441 8 441 44] (self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)) (val' : t) : ()
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 438 19 438 38] Invariant0.invariant' ( * self)}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 441 31 441 35] Inv0.inv self}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 441 37 441 40] Inv1.inv val'}
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 439 18 439 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 440 18 440 85] Seq.(==) (Model0.model ( ^ self)) (Seq.(++) (Seq.singleton val') (Model0.model ( * self))) }
    
end
module CargoDir_LinkedList_Impl0_PushFront
  type t
  use prelude.Borrow
  use seq.Seq
  use map.Map
  use prelude.Opaque
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Util_Unwrap_Interface as Unwrap0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv4.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv4.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv5.inv
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized as LookupUnsized0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get,
    function Unwrap0.unwrap = Unwrap0.unwrap,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv7.inv
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_NextOf as NextOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_PrevOf as PrevOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = t
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = t,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CargoDir_LinkedList_Impl0_WfToken as WfToken0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Contains0.contains = Contains0.contains,
    function Lookup0.lookup = Lookup0.lookup,
    function PrevOf0.prev_of = PrevOf0.prev_of,
    function NextOf0.next_of = NextOf0.next_of,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t),
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CargoDir_LinkedList_Impl0_Model as Model0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Lookup0.lookup = Lookup0.lookup
  clone CargoDir_LinkedList_Impl0_Invariant as Invariant0 with
    type t = t,
    predicate WfToken0.wf_token = WfToken0.wf_token,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CargoDir_LinkedList_Impl0_Append_Interface as Append0 with
    type t = t,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Inv0.inv = Inv1.inv,
    predicate Inv1.inv = Inv0.inv,
    function Model0.model = Model0.model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone Core_Mem_Swap_Interface as Swap0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t,
    predicate Inv0.inv = Inv1.inv
  clone CargoDir_LinkedList_Impl0_Singleton_Interface as Singleton0 with
    type t = t,
    predicate Inv0.inv = Inv2.inv,
    predicate Invariant0.invariant' = Invariant0.invariant',
    function Model0.model = Model0.model,
    predicate Inv1.inv = Inv0.inv
  let rec cfg push_front [#"/root/milli/creusot/cargo-dir/src/lib.rs" 441 8 441 44] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t)) (val' : t) : ()
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 438 19 438 38] Invariant0.invariant' ( * self)}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 441 31 441 35] Inv1.inv self}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 441 37 441 40] Inv2.inv val'}
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 439 18 439 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 440 18 440 85] Seq.(==) (Model0.model ( ^ self)) (Seq.(++) (Seq.singleton val') (Model0.model ( * self))) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) = self;
  var val' : t = val';
  var this : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t;
  var _8 : ();
  var _9 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
  var _10 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
  var _11 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
  var _12 : ();
  var _13 : borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
  {
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    this <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 442 27 442 47] Singleton0.singleton val');
    val' <- any t;
    goto BB2
  }
  BB2 {
    _9 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _9) };
    assume { Inv0.inv ( ^ _9) };
    _11 <- Borrow.borrow_mut this;
    this <-  ^ _11;
    assume { Inv0.inv ( ^ _11) };
    _10 <- Borrow.borrow_mut ( * _11);
    _11 <- { _11 with current = ( ^ _10) };
    assume { Inv0.inv ( ^ _10) };
    _8 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 443 12 443 43] Swap0.swap _9 _10);
    _9 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
    _10 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
    goto BB3
  }
  BB3 {
    assert { [@expl:type invariant] Inv1.inv _11 };
    assume { Resolve0.resolve _11 };
    _13 <- Borrow.borrow_mut ( * self);
    self <- { self with current = ( ^ _13) };
    assume { Inv0.inv ( ^ _13) };
    _12 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 444 12 444 29] Append0.append _13 this);
    _13 <- any borrowed (CargoDir_LinkedList_LinkedList_Type.t_linkedlist t);
    this <- any CargoDir_LinkedList_LinkedList_Type.t_linkedlist t;
    goto BB4
  }
  BB4 {
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve0.resolve self };
    _0 <- ();
    goto BB5
  }
  BB5 {
    return _0
  }
  
end
module CargoDir_LinkedList_Iter_Type
  use prelude.Borrow
  use prelude.Opaque
  use prelude.Ghost
  use prelude.Int
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  type t_iter 't =
    | C_Iter (CargoDir_LinkedList_LinkedList_Type.t_linkedlist 't) opaque_ptr (Ghost.ghost_ty int)
    
  let function iter_curr (self : t_iter 't) : opaque_ptr = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Iter _ a _ -> a
      end
  let function iter_l (self : t_iter 't) : CargoDir_LinkedList_LinkedList_Type.t_linkedlist 't
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Iter a _ _ -> a
      end
  let function iter_index (self : t_iter 't) : Ghost.ghost_ty int = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Iter _ _ a -> a
      end
end
module CargoDir_LinkedList_Impl1_Invariant_Stub
  type t
  use CargoDir_LinkedList_Iter_Type as CargoDir_LinkedList_Iter_Type
  predicate invariant' [#"/root/milli/creusot/cargo-dir/src/lib.rs" 470 8 470 38] (self : CargoDir_LinkedList_Iter_Type.t_iter t)
    
end
module CargoDir_LinkedList_Impl1_Invariant_Interface
  type t
  use CargoDir_LinkedList_Iter_Type as CargoDir_LinkedList_Iter_Type
  predicate invariant' [#"/root/milli/creusot/cargo-dir/src/lib.rs" 470 8 470 38] (self : CargoDir_LinkedList_Iter_Type.t_iter t)
    
  val invariant' [#"/root/milli/creusot/cargo-dir/src/lib.rs" 470 8 470 38] (self : CargoDir_LinkedList_Iter_Type.t_iter t) : bool
    ensures { result = invariant' self }
    
end
module CargoDir_LinkedList_Impl1_Invariant
  type t
  use prelude.Ghost
  use seq.Seq
  use prelude.Int
  use prelude.Opaque
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Stub as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic_Stub as IndexLogic0 with
    type t = opaque_ptr
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_Model_Stub as Model0 with
    type t = t
  clone CargoDir_LinkedList_Impl0_Invariant_Stub as Invariant0 with
    type t = t
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Stub as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv0.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_Iter_Type as CargoDir_LinkedList_Iter_Type
  predicate invariant' [#"/root/milli/creusot/cargo-dir/src/lib.rs" 470 8 470 38] (self : CargoDir_LinkedList_Iter_Type.t_iter t)
    
   =
    [#"/root/milli/creusot/cargo-dir/src/lib.rs" 471 12 481 13] if CargoDir_LinkedList_Iter_Type.iter_curr self <> NullLogic0.null_logic () then
      Invariant0.invariant' (CargoDir_LinkedList_Iter_Type.iter_l self) /\ Ghost.inner (CargoDir_LinkedList_Iter_Type.iter_index self) < Seq.length (Model0.model (CargoDir_LinkedList_Iter_Type.iter_l self)) /\ CargoDir_LinkedList_Iter_Type.iter_curr self = IndexLogic0.index_logic (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs (CargoDir_LinkedList_Iter_Type.iter_l self)) (Ghost.inner (CargoDir_LinkedList_Iter_Type.iter_index self)) /\ Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs (CargoDir_LinkedList_Iter_Type.iter_l self))) > 0 /\ Ghost.inner (CargoDir_LinkedList_Iter_Type.iter_index self) >= 0
    else
      true
    
  val invariant' [#"/root/milli/creusot/cargo-dir/src/lib.rs" 470 8 470 38] (self : CargoDir_LinkedList_Iter_Type.t_iter t) : bool
    ensures { result = invariant' self }
    
end
module CargoDir_LinkedList_Impl0_Iter_Interface
  type t
  use prelude.Ghost
  use seq.Seq
  use prelude.Int
  use prelude.Borrow
  use CargoDir_LinkedList_Iter_Type as CargoDir_LinkedList_Iter_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = CargoDir_LinkedList_Iter_Type.t_iter t
  clone CargoDir_LinkedList_Impl1_Invariant_Stub as Invariant1 with
    type t = t
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone CargoDir_LinkedList_Impl0_Invariant_Stub as Invariant0 with
    type t = t
  val iter [#"/root/milli/creusot/cargo-dir/src/lib.rs" 452 8 452 41] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) : CargoDir_LinkedList_Iter_Type.t_iter t
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 447 19 447 38] Invariant0.invariant' self}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 448 19 448 38] Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self)) > 0}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 452 21 452 25] Inv0.inv self}
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 449 18 449 36] Invariant1.invariant' result }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 452 30 452 41] Inv1.inv result }
    
end
module CargoDir_LinkedList_Impl0_Iter
  type t
  use prelude.Ghost
  use prelude.Int
  use prelude.Borrow
  use seq.Seq
  use map.Map
  use prelude.Opaque
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv7.inv,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv5.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Util_Unwrap_Interface as Unwrap0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv4.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv4.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv5.inv
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized as LookupUnsized0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get,
    function Unwrap0.unwrap = Unwrap0.unwrap,
    predicate Inv0.inv = Inv6.inv,
    predicate Inv1.inv = Inv7.inv
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_NextOf as NextOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_PrevOf as PrevOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized
  use CargoDir_LinkedList_Iter_Type as CargoDir_LinkedList_Iter_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = CargoDir_LinkedList_Iter_Type.t_iter t
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = CargoDir_LinkedList_Iter_Type.t_iter t,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CargoDir_LinkedList_Impl0_Model as Model0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Lookup0.lookup = Lookup0.lookup
  clone CargoDir_LinkedList_Impl0_WfToken as WfToken0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Contains0.contains = Contains0.contains,
    function Lookup0.lookup = Lookup0.lookup,
    function PrevOf0.prev_of = PrevOf0.prev_of,
    function NextOf0.next_of = NextOf0.next_of,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t,
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CargoDir_LinkedList_Impl0_Invariant as Invariant0 with
    type t = t,
    predicate WfToken0.wf_token = WfToken0.wf_token,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CargoDir_LinkedList_Impl1_Invariant as Invariant1 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    predicate Invariant0.invariant' = Invariant0.invariant',
    function Model0.model = Model0.model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv3.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = CargoDir_LinkedList_LinkedList_Type.t_linkedlist t
  let rec cfg iter [#"/root/milli/creusot/cargo-dir/src/lib.rs" 452 8 452 41] [@cfg:stackify] [@cfg:subregion_analysis] (self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t) : CargoDir_LinkedList_Iter_Type.t_iter t
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 447 19 447 38] Invariant0.invariant' self}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 448 19 448 38] Seq.length (Ghost.inner (CargoDir_LinkedList_LinkedList_Type.linkedlist_ptrs self)) > 0}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 452 21 452 25] Inv1.inv self}
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 449 18 449 36] Invariant1.invariant' result }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 452 30 452 41] Inv2.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : CargoDir_LinkedList_Iter_Type.t_iter t;
  var self : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t = self;
  var _6 : CargoDir_LinkedList_LinkedList_Type.t_linkedlist t;
  var _8 : Ghost.ghost_ty int;
  {
    goto BB0
  }
  BB0 {
    _6 <- self;
    assert { [@expl:type invariant] Inv0.inv _6 };
    assume { Resolve0.resolve _6 };
    assert { [@expl:type invariant] Inv1.inv self };
    assume { Resolve1.resolve self };
    _8 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 456 23 456 29] Ghost.new 0);
    goto BB1
  }
  BB1 {
    _0 <- CargoDir_LinkedList_Iter_Type.C_Iter _6 (CargoDir_LinkedList_LinkedList_Type.linkedlist_head self) _8;
    _8 <- any Ghost.ghost_ty int;
    return _0
  }
  
end
module CreusotContracts_Model_Impl5_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl5_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl5_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy =
    [#"/root/creusot/creusot-contracts/src/model.rs" 83 8 83 31] ShallowModel0.shallow_model self
  val shallow_model (self : t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_GhostPtr_Impl1_PtrAsRef_Interface
  type t
  use prelude.Borrow
  use prelude.Opaque
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = t
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized_Stub as LookupUnsized0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains_Stub as Contains0 with
    type k = opaque_ptr,
    type v = t
  clone CreusotContracts_Model_Impl5_ShallowModel_Stub as ShallowModel0 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t,
    type ShallowModelTy0.shallowModelTy = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr t
  val ptr_as_ref (self : CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken t) (ptr : opaque_ptr) : t
    requires {[#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 66 4 66 36] Contains0.contains (ShallowModel0.shallow_model self) ptr}
    requires {[#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 68 23 68 27] Inv0.inv self}
    ensures { [#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 67 14 67 51] result = LookupUnsized0.lookup_unsized (ShallowModel0.shallow_model self) ptr }
    ensures { [#"/root/creusot/creusot-contracts/src/ghost_ptr.rs" 68 4 68 49] Inv1.inv result }
    
end
module CargoDir_LinkedList_Impl1_Next_Interface
  type t
  use prelude.Borrow
  use prelude.Ghost
  use seq.Seq
  use prelude.Int
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv1 with
    type t = Core_Option_Option_Type.t_option t
  clone CargoDir_LinkedList_Impl0_Model_Stub as Model0 with
    type t = t
  use CargoDir_LinkedList_Iter_Type as CargoDir_LinkedList_Iter_Type
  clone CreusotContracts_Invariant_Inv_Stub as Inv0 with
    type t = borrowed (CargoDir_LinkedList_Iter_Type.t_iter t)
  clone CargoDir_LinkedList_Impl1_Invariant_Stub as Invariant0 with
    type t = t
  val next [#"/root/milli/creusot/cargo-dir/src/lib.rs" 506 8 506 47] (self : borrowed (CargoDir_LinkedList_Iter_Type.t_iter t)) : Core_Option_Option_Type.t_option t
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 496 19 496 38] Invariant0.invariant' ( * self)}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 506 25 506 29] Inv0.inv self}
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 497 18 497 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 498 18 501 9] match (result) with
      | Core_Option_Option_Type.C_Some val' -> val' = Seq.get (Model0.model (CargoDir_LinkedList_Iter_Type.iter_l ( * self))) (Ghost.inner (CargoDir_LinkedList_Iter_Type.iter_index ( * self)))
      | Core_Option_Option_Type.C_None -> true
      end }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 502 18 505 9] match (result) with
      | Core_Option_Option_Type.C_Some val' -> Ghost.inner (CargoDir_LinkedList_Iter_Type.iter_index ( ^ self)) = Ghost.inner (CargoDir_LinkedList_Iter_Type.iter_index ( * self)) + 1
      | Core_Option_Option_Type.C_None -> true
      end }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 506 34 506 47] Inv1.inv result }
    
end
module CargoDir_LinkedList_Impl1_Next
  type t
  use prelude.Borrow
  use prelude.Ghost
  use prelude.Int
  use seq.Seq
  use map.Map
  use prelude.Opaque
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use CargoDir_LinkedList_Node_Type as CargoDir_LinkedList_Node_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  use map.Map
  clone CreusotContracts_Invariant_Inv_Interface as Inv12 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial12 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv12.inv,
    axiom .
  use CreusotContracts_Logic_Fmap_FMap_Type as CreusotContracts_Logic_Fmap_FMap_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv11 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial11 with
    type t = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv11.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv10 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial10 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv10.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv9 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial9 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv9.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Mk_Interface as Mk0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_View_Interface as View0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv11.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv12.inv,
    axiom .
  clone CreusotContracts_Util_Unwrap_Interface as Unwrap0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv10.inv,
    axiom .
  use CreusotContracts_GhostPtr_GhostPtrToken_Type as CreusotContracts_GhostPtr_GhostPtrToken_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv8 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial8 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv8.inv,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_Get as Get0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function View0.view = View0.view,
    predicate Inv0.inv = Inv11.inv,
    function Mk0.mk = Mk0.mk,
    predicate Inv1.inv = Inv12.inv
  clone CreusotContracts_Invariant_Inv_Interface as Inv7 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial7 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv7.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv6 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)
  clone TyInv_Trivial as TyInv_Trivial6 with
    type t = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv6.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv5 with
    type t = opaque_ptr
  clone TyInv_Trivial as TyInv_Trivial5 with
    type t = opaque_ptr,
    predicate Inv0.inv = Inv5.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv4 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t))
  clone TyInv_Trivial as TyInv_Trivial4 with
    type t = Map.map opaque_ptr (Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t)),
    predicate Inv0.inv = Inv4.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv3 with
    type t = Core_Option_Option_Type.t_option t
  clone TyInv_Trivial as TyInv_Trivial3 with
    type t = Core_Option_Option_Type.t_option t,
    predicate Inv0.inv = Inv3.inv,
    axiom .
  clone CreusotContracts_GhostPtr_Impl2_AddrLogic_Interface as AddrLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Fmap_Impl0_Contains as Contains0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get
  clone CreusotContracts_GhostPtr_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Logic_Ops_Impl6_IndexLogic as IndexLogic0 with
    type t = opaque_ptr
  clone CreusotContracts_GhostPtr_Impl2_NullLogic_Interface as NullLogic0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv7.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  use CargoDir_LinkedList_LinkedList_Type as CargoDir_LinkedList_LinkedList_Type
  clone CargoDir_LinkedList_Impl0_NextOf as NextOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv7.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CargoDir_LinkedList_Impl0_PrevOf as PrevOf0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv7.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic,
    axiom .
  clone CreusotContracts_Logic_Fmap_Impl0_LookupUnsized as LookupUnsized0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function Get0.get = Get0.get,
    function Unwrap0.unwrap = Unwrap0.unwrap,
    predicate Inv0.inv = Inv9.inv,
    predicate Inv1.inv = Inv10.inv
  clone CreusotContracts_Logic_Fmap_Impl0_Lookup as Lookup0 with
    type k = opaque_ptr,
    type v = CargoDir_LinkedList_Node_Type.t_node t,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized
  clone CargoDir_LinkedList_Impl0_WfToken as WfToken0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Contains0.contains = Contains0.contains,
    function Lookup0.lookup = Lookup0.lookup,
    function PrevOf0.prev_of = PrevOf0.prev_of,
    function NextOf0.next_of = NextOf0.next_of,
    axiom .
  clone CargoDir_LinkedList_Impl0_Invariant as Invariant1 with
    type t = t,
    predicate WfToken0.wf_token = WfToken0.wf_token,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv7.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Invariant_Inv_Interface as Inv2 with
    type t = t
  clone TyInv_Trivial as TyInv_Trivial2 with
    type t = t,
    predicate Inv0.inv = Inv2.inv,
    axiom .
  clone CreusotContracts_Invariant_Inv_Interface as Inv1 with
    type t = CargoDir_LinkedList_Node_Type.t_node t
  clone TyInv_Trivial as TyInv_Trivial1 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    predicate Inv0.inv = Inv1.inv,
    axiom .
  use CargoDir_LinkedList_Iter_Type as CargoDir_LinkedList_Iter_Type
  clone CreusotContracts_Invariant_Inv_Interface as Inv0 with
    type t = borrowed (CargoDir_LinkedList_Iter_Type.t_iter t)
  clone TyInv_Trivial as TyInv_Trivial0 with
    type t = borrowed (CargoDir_LinkedList_Iter_Type.t_iter t),
    predicate Inv0.inv = Inv0.inv,
    axiom .
  clone CreusotContracts_Model_Impl5_ShallowModel as ShallowModel1 with
    type t = CreusotContracts_GhostPtr_GhostPtrToken_Type.t_ghostptrtoken (CargoDir_LinkedList_Node_Type.t_node t),
    type ShallowModelTy0.shallowModelTy = CreusotContracts_Logic_Fmap_FMap_Type.t_fmap opaque_ptr (CargoDir_LinkedList_Node_Type.t_node t),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CargoDir_LinkedList_Impl0_Model as Model0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function Lookup0.lookup = Lookup0.lookup
  clone CargoDir_LinkedList_Impl1_Invariant as Invariant0 with
    type t = t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    predicate Invariant0.invariant' = Invariant1.invariant',
    function Model0.model = Model0.model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Inv0.inv = Inv7.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = t
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = CargoDir_LinkedList_Node_Type.t_node t
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = CargoDir_LinkedList_Iter_Type.t_iter t
  clone CreusotContracts_GhostPtr_Impl1_PtrAsRef_Interface as PtrAsRef0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function Contains0.contains = Contains0.contains,
    predicate Inv0.inv = Inv8.inv,
    function LookupUnsized0.lookup_unsized = LookupUnsized0.lookup_unsized,
    predicate Inv1.inv = Inv1.inv
  clone Core_Ptr_ConstPtr_Impl0_IsNull_Interface as IsNull0 with
    type t = CargoDir_LinkedList_Node_Type.t_node t,
    function NullLogic0.null_logic = NullLogic0.null_logic,
    predicate Inv0.inv = Inv7.inv,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function Contains0.contains = Contains0.contains,
    function AddrLogic0.addr_logic = AddrLogic0.addr_logic
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = ()
  clone CargoDir_Lemmas_MapSetCommute_Interface as MapSetCommute0 with
    type k = opaque_ptr,
    type v = Core_Option_Option_Type.t_option (CargoDir_LinkedList_Node_Type.t_node t),
    predicate Inv0.inv = Inv4.inv,
    predicate Inv1.inv = Inv5.inv,
    predicate Inv2.inv = Inv6.inv,
    axiom .
  let rec cfg next [#"/root/milli/creusot/cargo-dir/src/lib.rs" 506 8 506 47] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (CargoDir_LinkedList_Iter_Type.t_iter t)) : Core_Option_Option_Type.t_option t
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 496 19 496 38] Invariant0.invariant' ( * self)}
    requires {[#"/root/milli/creusot/cargo-dir/src/lib.rs" 506 25 506 29] Inv0.inv self}
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 497 18 497 37] Invariant0.invariant' ( ^ self) }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 498 18 501 9] match (result) with
      | Core_Option_Option_Type.C_Some val' -> val' = Seq.get (Model0.model (CargoDir_LinkedList_Iter_Type.iter_l ( * self))) (Ghost.inner (CargoDir_LinkedList_Iter_Type.iter_index ( * self)))
      | Core_Option_Option_Type.C_None -> true
      end }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 502 18 505 9] match (result) with
      | Core_Option_Option_Type.C_Some val' -> Ghost.inner (CargoDir_LinkedList_Iter_Type.iter_index ( ^ self)) = Ghost.inner (CargoDir_LinkedList_Iter_Type.iter_index ( * self)) + 1
      | Core_Option_Option_Type.C_None -> true
      end }
    ensures { [#"/root/milli/creusot/cargo-dir/src/lib.rs" 506 34 506 47] Inv3.inv result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option t;
  var self : borrowed (CargoDir_LinkedList_Iter_Type.t_iter t) = self;
  var _6 : ();
  var _8 : bool;
  var node : CargoDir_LinkedList_Node_Type.t_node t;
  var _17 : Ghost.ghost_ty int;
  var _20 : t;
  {
    goto BB0
  }
  BB0 {
    _6 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 507 12 507 62] ());
    assume { Resolve0.resolve _6 };
    _8 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 508 15 508 34] IsNull0.is_null (CargoDir_LinkedList_Iter_Type.iter_curr ( * self)));
    goto BB1
  }
  BB1 {
    switch (_8)
      | False -> goto BB3
      | True -> goto BB2
      end
  }
  BB2 {
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve1.resolve self };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB6
  }
  BB3 {
    assert { [@expl:assertion] [#"/root/milli/creusot/cargo-dir/src/lib.rs" 512 12 512 55] WfToken0.wf_token (CargoDir_LinkedList_Iter_Type.iter_l ( * self)) (Ghost.inner (CargoDir_LinkedList_Iter_Type.iter_index ( * self))) };
    node <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 513 23 513 57] PtrAsRef0.ptr_as_ref (CargoDir_LinkedList_LinkedList_Type.linkedlist_token (CargoDir_LinkedList_Iter_Type.iter_l ( * self))) (CargoDir_LinkedList_Iter_Type.iter_curr ( * self)));
    goto BB4
  }
  BB4 {
    self <- { self with current = (let CargoDir_LinkedList_Iter_Type.C_Iter a b c =  * self in CargoDir_LinkedList_Iter_Type.C_Iter a (CargoDir_LinkedList_Node_Type.node_next node) c) };
    _17 <- ([#"/root/milli/creusot/cargo-dir/src/lib.rs" 515 25 515 45] Ghost.new (Ghost.inner (CargoDir_LinkedList_Iter_Type.iter_index ( * self)) + 1));
    goto BB5
  }
  BB5 {
    self <- { self with current = (let CargoDir_LinkedList_Iter_Type.C_Iter a b c =  * self in CargoDir_LinkedList_Iter_Type.C_Iter a b _17) };
    _17 <- any Ghost.ghost_ty int;
    assert { [@expl:type invariant] Inv0.inv self };
    assume { Resolve1.resolve self };
    _20 <- CargoDir_LinkedList_Node_Type.node_data node;
    assert { [@expl:type invariant] Inv1.inv node };
    assume { Resolve2.resolve node };
    assert { [@expl:type invariant] Inv2.inv _20 };
    assume { Resolve3.resolve _20 };
    _0 <- Core_Option_Option_Type.C_Some _20;
    goto BB6
  }
  BB6 {
    return _0
  }
  
end
